<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Research Office — zeta-zero-cafe (TEST)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="/css/bundle.css?v=1" rel="stylesheet" />

  <!-- Same MathJax config as chapters (for paragraph preview + memo preview if needed later) -->
  <script src="/cafes/zeta-zero-cafe/notebook/math/mathconfig.js"></script>
  <script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

  <style>
    :root { --thumbW: 110px; --thumbH: 150px; }
    body { padding: 16px; }
    .wrap { display: grid; grid-template-columns: 320px 1fr; gap: 18px; }
    .card { background: var(--card); border:1px solid var(--line); border-radius:10px; padding:12px; }
    .left .viewer { height: 440px; display:flex; align-items:center; justify-content:center; overflow:auto; background:#0c1217; border-radius:8px; border:1px solid var(--line); }
    .viewer img { max-width:100%; height:auto; display:block; }
    .viewer-ctrls { display:flex; gap:8px; justify-content:flex-start; margin-top:10px; }
    .viewer-ctrls button { min-width:64px; }

    .refstrip { display:flex; gap:12px; overflow-x:auto; padding:6px 2px; }
    .ref { position:relative; width:var(--thumbW); height:var(--thumbH); border-radius:10px; border:2px solid var(--line); background:#0c1217; display:flex; align-items:center; justify-content:center; flex:0 0 auto; }
    .ref.primary { border:4px solid #f6b73c; } /* thicker orange border */
    .ref.active  { box-shadow:0 0 0 3px rgba(90,200,255,.35) inset; }
    .ref img { width:calc(var(--thumbW) - 22px); height:auto; border-radius:6px; }
    .badge { position:absolute; top:4px; left:6px; background:#111a; color:#fff; font-size:11px; padding:2px 6px; border-radius:6px; }
    .ref .kill { position:absolute; top:4px; right:4px; background:#2b0d11; border:1px solid #933; color:#f7b; width:20px; height:20px; font-size:12px; border-radius:6px; line-height:18px; text-align:center; cursor:pointer; }
    .ref.primary .kill { display:none; } /* primary cannot be removed */

    .row { display:grid; grid-template-columns: 1fr; gap:12px; }
    .hdr  { display:flex; align-items:center; gap:10px; }
    .hdr small { opacity:.6; }
    .tiny { font-size:12px; opacity:.65; }

    textarea { width:100%; min-height:160px; resize:vertical; }
    .token-chips { display:flex; flex-wrap:wrap; gap:6px; margin-top:8px; }
    .chip { font-size:12px; border:1px solid var(--line); border-radius:999px; padding:2px 8px; background:#10161d; }
    .chip.hot { background:#0b2a3a; border-color:#39a0db; color:#cfefff; }

    #status { font-size:12px; opacity:.7; margin-top:6px; }
    .controls-inline { display:flex; align-items:center; gap:8px; }
    select, button { height:28px; }
    .spaced { margin-top:12px; }
  </style>
</head>
<body>
  <h1>Research Office — zeta-zero-cafe (TEST)</h1>

  <div class="wrap">
    <!-- LEFT: viewer -->
    <div class="left card">
      <div class="hdr"><strong>Grid Stub (page viewer)</strong></div>
      <div class="viewer">
        <img id="viewerImg" alt="page thumbnail" />
      </div>
      <div class="viewer-ctrls">
        <button id="btnPrev">◀</button>
        <button id="btnPrimary">primary</button>
        <button id="btnNext">▶</button>
        <button id="btnAdd">[Add page]</button>
      </div>
      <div id="status" class="tiny">—</div>
    </div>

    <!-- RIGHT: everything else -->
    <div class="right row">
      <!-- Pages referenced in memo -->
      <div class="card">
        <div class="hdr"><strong>Pages referenced in memo</strong></div>
        <div id="refstrip" class="refstrip"></div>
      </div>

      <!-- Paragraph preview -->
      <div class="card">
        <div class="hdr">
          <strong>Paragraph preview</strong>
          <small id="paraTag">#—</small>
        </div>
        <div id="paraPreview" class="spaced tiny">Select a chapter/paragraph (mocked here).</div>
      </div>

      <!-- Memo to self -->
      <div class="card">
        <div class="hdr"><strong>Memo to self (Markdown + LaTeX)</strong></div>
        <textarea id="memoTA">[mm|p7=x,y]</textarea>

        <!-- chips that mirror tokens and highlight current page -->
        <div id="chips" class="token-chips"></div>

        <div class="spaced controls-inline">
          <button id="btnSaveDraft">Save draft</button>
          <button id="btnSaveVersion">Save version</button>
          <button id="btnExportJSON">Export memo JSON</button>
          <button id="btnExportAll">Export ALL drafts</button>
          <button id="btnChoose">Choose File</button>
          <button id="btnDiscord">Submit via Discord</button>
        </div>
      </div>

      <!-- Rendered output (test only, not the real preview) -->
      <div class="card">
        <div class="hdr"><strong>Rendered output (test-only)</strong></div>
        <div id="renderOut" class="spaced tiny">—</div>
      </div>
    </div>
  </div>

  <script>
  // ---------- tiny helpers ----------
  const $ = (s, r=document) => r.querySelector(s);
  const $$ = (s, r=document) => Array.from(r.querySelectorAll(s));
  const pad3 = n => String(n).padStart(3,'0');
  const setStatus = (m) => { $('#status').textContent = m; };

  // ---------- mock chapter/para (fixed) ----------
  const primaryPage = 7; // pretend resolver concluded p.7
  let currentPage  = primaryPage;

  // ---------- memo token model ----------
  // tokens look like: [mm|pN=...]
  // "deleted" tokens look like: [del]mm|pN=...]
  const tokenRE = /\[(?<del>del\])?mm\|p(?<page>\d+)\s*=\s*([^\]\n]+)\]/g;

  function parseTokens(text) {
    tokenRE.lastIndex = 0;
    const items = [];
    let m;
    while ((m = tokenRE.exec(text))) {
      items.push({
        raw: m[0],
        start: m.index,
        end: m.index + m[0].length,
        page: Number(m.groups.page),
        deleted: !!m.groups.del,
      });
    }
    return items;
  }

  function hasLiveTokenForPage(tokens, page) {
    return tokens.some(t => t.page === page && !t.deleted);
  }

  function markDeletedForPage(text, page) {
    // prefix [del] for every LIVE token of this page
    return text.replace(tokenRE, (full, del, pg) => {
      const p = Number(pg);
      if (p === page && !del) return full.replace('[mm|','[del]mm|');
      return full;
    });
  }

  function reinstateForPage(text, page) {
    // remove [del] for tokens of this page
    return text.replace(tokenRE, (full, del, pg) => {
      const p = Number(pg);
      if (p === page && del) return full.replace('[del]mm|','[mm|');
      return full;
    });
  }

  function addTokenIfNeeded(text, page) {
    const tokens = parseTokens(text);
    if (page === primaryPage) return text; // never add primary
    if (hasLiveTokenForPage(tokens, page)) return text; // already present
    // if only deleted tokens exist, reinstate them
    if (tokens.some(t => t.page === page && t.deleted)) {
      return reinstateForPage(text, page);
    }
    // otherwise append a skeletal token
    const add = `[mm|p${page}=x,y]`;
    return (text.endsWith('\n') ? text : text + '\n') + add + '\n';
  }

  // ---------- referenced pages strip (primary first, then tokens in encounter order) ----------
  function pagesFromMemo(text) {
    const tokens = parseTokens(text);
    const order = [];
    const seen = new Set();
    for (const t of tokens) {
      if (t.deleted) continue;
      if (!seen.has(t.page)) { seen.add(t.page); order.push(t.page); }
    }
    // primary first, then order from tokens (without primary duplication)
    return [primaryPage, ...order.filter(p => p !== primaryPage)];
  }

  function renderRefStrip() {
    const strip = $('#refstrip');
    strip.innerHTML = '';

    const list = pagesFromMemo($('#memoTA').value).sort((a, b) => a - b);
    for (const p of list) {
      const ref = document.createElement('div');
      ref.className = 'ref' + (p===primaryPage ? ' primary' : '') + (p===currentPage ? ' active' : '');
      ref.dataset.page = p;

      const img = document.createElement('img');
      img.alt = `p.${p}`;
      img.src = `/cafes/zeta-zero-cafe/sources/thumbs/page-${pad3(p)}.jpg`;
      ref.appendChild(img);

      const badge = document.createElement('div');
      badge.className = 'badge';
      badge.textContent = `p.${p}`;
      ref.appendChild(badge);

      const kill = document.createElement('div');
      kill.className = 'kill';
      kill.textContent = '×';
      kill.title = 'Mark tokens as [del] (page removed from strip)';
      ref.appendChild(kill);

      // click thumbnail → activate page
      ref.addEventListener('click', (ev) => {
        if (ev.target === kill) return; // handled separately
        setCurrentPage(p);
      });

      // delete → mark [del] in memo (do NOT prune), then refresh
      kill.addEventListener('click', (ev) => {
        ev.stopPropagation();
        if (p === primaryPage) return;
        const ta = $('#memoTA');
        ta.value = markDeletedForPage(ta.value, p);
        onMemoChanged();
      });

      strip.appendChild(ref);
    }
    // scroll active into view
    const active = strip.querySelector('.ref.active');
    if (active) active.scrollIntoView({ inline: 'center', block: 'nearest', behavior: 'smooth' });
  }

  // ---------- chips under the memo to emphasise active page tokens ----------
  function renderChips() {
    const holder = $('#chips');
    holder.innerHTML = '';
    const tokens = parseTokens($('#memoTA').value);
    for (const t of tokens) {
      const c = document.createElement('span');
      c.className = 'chip' + (t.page === currentPage && !t.deleted ? ' hot' : '');
      c.textContent = (t.deleted ? '[del] ' : '') + `p${t.page}`;
      holder.appendChild(c);
    }
  }

  // ---------- viewer + navigation ----------
  function setCurrentPage(p) {
    currentPage = Math.max(1, p);
    const img = $('#viewerImg');
    img.src = `/cafes/zeta-zero-cafe/sources/thumbs/page-${pad3(currentPage)}.jpg`;
    img.onload = () => setStatus(`Loaded thumbnail p.${currentPage}.`);
    img.onerror = () => setStatus(`Missing thumbnail p.${currentPage}.`);
    renderRefStrip();
    renderChips();
  }

  $('#btnPrev').addEventListener('click', () => setCurrentPage(currentPage - 1));
  $('#btnNext').addEventListener('click', () => setCurrentPage(currentPage + 1));
  $('#btnPrimary').addEventListener('click', () => setCurrentPage(primaryPage));
  $('#btnAdd').addEventListener('click', () => {
    if (currentPage === primaryPage) return; // never tokenise primary
    const ta = $('#memoTA');
    ta.value = addTokenIfNeeded(ta.value, currentPage);
    onMemoChanged();
  });

  // ---------- memo handlers ----------
  function onMemoChanged() {
    renderRefStrip();
    renderChips();
    // simple rendered echo for test visibility
    $('#renderOut').textContent = $('#memoTA').value.trim() || '—';
  }
  $('#memoTA').addEventListener('input', onMemoChanged);

  // ---------- fake buttons (message boxes) ----------
  const ping = (m) => alert(m);
  $('#btnSaveDraft').addEventListener('click', () => ping('Saving draft'));
  $('#btnSaveVersion').addEventListener('click', () => ping('Saving version'));
  $('#btnExportJSON').addEventListener('click', () => ping('Exporting memo JSON'));
  $('#btnExportAll').addEventListener('click', () => ping('Export ALL drafts'));
  $('#btnChoose').addEventListener('click', () => ping('Choosing File'));
  $('#btnDiscord').addEventListener('click', () => ping('Submitting via Discord'));

  // ---------- bootstrap ----------
  (function init() {
    // viewer on primary
    setCurrentPage(primaryPage);
    // ensure memo exists & reflect
    onMemoChanged();
    // fake paragraph preview content (math to confirm MathJax path is fine)
    $('#paraTag').textContent = '#osf-1';
    $('#paraPreview').textContent = 'The focus in this document is on the classic Basel problem...';
    if (window.MathJax?.typesetPromise) window.MathJax.typesetPromise();
  })();
  </script>
</body>
</html>

