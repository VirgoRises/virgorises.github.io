<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Source document</title>
  <link rel="stylesheet" href="/css/10-components/research-office.css">
  <style>
    body{background:#0d1117;color:#e6edf3;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    .wrap{max-width:1200px;margin:0 auto;padding:16px}
    .bar{display:flex;gap:8px;align-items:center;margin-bottom:12px;flex-wrap:wrap}
    .btn{background:#161b22;border:1px solid #30363d;padding:6px 10px;border-radius:8px;color:#e6edf3;text-decoration:none;cursor:pointer}
    .btn:hover{background:#1f242d}
    .badge{font-size:.8rem;opacity:.85;border:1px solid #30363d;border-radius:999px;padding:2px 8px}
    .cols{display:grid;grid-template-columns:280px 1fr;gap:16px}
    .thumbs{background:#0b0f14;border:1px solid #30363d;border-radius:12px;padding:12px;height:70vh;overflow:auto}
    .viewer{background:#0b0f14;border:1px solid #30363d;border-radius:12px;padding:12px;height:70vh;overflow:auto;position:relative}
    /* Stage: page + overlays */
    #stage{position:relative}
    #pageCanvas{display:block;margin:0 auto;position:relative;z-index:2}
    #overlay{position:absolute;left:0;top:0;pointer-events:none;z-index:3}
    .hl-badge{position:absolute;left:8px;top:8px;background:#1f6feb22;border:1px solid #1f6feb;border-radius:6px;padding:2px 6px;font-size:.8rem;z-index:4}
    /* Context strips (p−1 bottom at top edge, p top at bottom edge) */
    .strip{position:absolute;left:50%;transform:translateX(-50%);width:100%;pointer-events:none;border-radius:8px;box-shadow:0 2px 10px rgba(0,0,0,.35)}
    #prevStripWrap{top:0}
    #nextStripWrap{bottom:0}
    .strip .label{position:absolute;left:8px;top:6px;font-size:.75rem;opacity:.85;background:#0b0f14d0;border:1px solid #30363d;padding:2px 6px;border-radius:6px;pointer-events:auto}
    .strip canvas{display:block;width:100%;height:auto;border:1px dashed #30363d;border-radius:8px;background:#0b0f14}
    /* Stacking toggle */
    /* default = preview above strips */
    .strip{z-index:1}
    #pageCanvas{z-index:2}
    #overlay{z-index:3}
    /* when context is on top */
    #stage.context-front .strip{z-index:5}
    #stage.context-front #pageCanvas{z-index:2}
    #stage.context-front #overlay{z-index:4}

    .controls{display:flex;gap:8px;margin-top:8px;flex-wrap:wrap}
    .thumb{margin:8px 0;border:1px solid #30363d;border-radius:8px;overflow:hidden;cursor:pointer}
    .thumb.active{box-shadow:0 0 0 2px #1f6feb inset}
    .thumb canvas{width:100% !important;height:auto !important}
    .sep{opacity:.4}
  </style>
  <script src="https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
</head>
<body>
  <div class="wrap">
    <div class="bar">
      <a id="backBtn" class="btn" href="javascript:history.back()">← Back</a>
      <span id="pdfName" class="btn badge"></span>
      <span class="btn badge">Linked from <span id="fromTag">—</span></span>
      <span class="sep">|</span>
      <a id="openOriginal" class="btn" target="_blank" rel="noopener">Open original</a>
      <a id="downloadPdf" class="btn" download>Download</a>
      <span class="sep">|</span>
      <span id="pageBadge" class="btn badge">p.— / —</span>
      <button class="btn" id="toggleContext">Context view</button>
      <button class="btn" id="toggleStack">Context on top</button>
    </div>

    <div class="cols">
      <div class="thumbs" id="thumbs"></div>

      <div class="viewer" id="viewer">
        <div class="hl-badge" id="hl" style="display:none"></div>

        <!-- Stage: main page + overlays -->
        <div id="stage">
          <canvas id="pageCanvas"></canvas>
          <canvas id="overlay"></canvas>

          <!-- Overlaid context strips -->
          <div id="prevStripWrap" class="strip" style="display:none">
            <span class="label">Prev (p−1) — bottom</span>
            <canvas id="prevStrip"></canvas>
          </div>
          <div id="nextStripWrap" class="strip" style="display:none">
            <span class="label">Current (p) — top</span>
            <canvas id="nextStrip"></canvas>
          </div>
        </div>
      </div>
    </div>

    <div class="controls">
      <button class="btn" id="prevBtn">Prev</button>
      <button class="btn" id="nextBtn">Next</button>
      <button class="btn" id="zoomOut">−</button>
      <button class="btn" id="zoomIn">+</button>
      <button class="btn" id="fitWidth">Fit width</button>
      <button class="btn" id="resetZoom">100%</button>
    </div>
  </div>

<script>
(async () => {
  if (!window.pdfjsLib) { alert("PDF.js failed to load."); return; }
  const pdfjsLib = window.pdfjsLib;
  pdfjsLib.GlobalWorkerOptions.workerSrc = "https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.worker.min.js";

  // ---------- helpers ----------
  const $ = sel => document.querySelector(sel);
  const clamp=(n,lo,hi)=> Math.max(lo, Math.min(hi,n));
  const debounce=(fn,ms=120)=>{ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); }; };
  const norm = s => (s||'').toLowerCase().replace(/\s+/g,' ').replace(/[\u00ad\u200b]/g,'').trim();

  const u = new URL(location.href);
  const pdfbnRaw = (u.searchParams.get("pdf") || "Old_main").replace(/\.pdf$/i,"");
  const paraRaw  = u.searchParams.get("para") || "";
  const chapter  = decodeURIComponent(u.searchParams.get("chapter") || "");
  const returnUrl= u.searchParams.get("return") || document.referrer || "/";
  const fromQP   = u.searchParams.get("from");
  const toQP     = u.searchParams.get("to");
  const pageQP   = u.searchParams.get("page");

  const m = location.pathname.match(/^\/cafes\/([^\/]+)/);
  const slug = m ? m[1] : "zeta-zero-cafe";
  const cafeRoot = `/cafes/${slug}`;

  $("#pdfName").textContent = `${pdfbnRaw}.pdf`;
  $("#fromTag").textContent = paraRaw || "—";
  $("#backBtn").onclick = (e)=>{ e.preventDefault(); if (returnUrl) location.href = returnUrl; else history.back(); };

  const candidatePdfUrls = [
    `${cafeRoot}/sources/${pdfbnRaw}.pdf`,
    `${cafeRoot}/pdf/${pdfbnRaw}.pdf`,
    `${cafeRoot}/${pdfbnRaw}.pdf`,
    `/sources/${pdfbnRaw}.pdf`,
    `/pdf/${pdfbnRaw}.pdf`
  ];
  const candidateMapUrls = [
    `/data/cafes/${slug}/sources/${pdfbnRaw}.map.json`,
    `/data/cafes/${slug}/${pdfbnRaw}.map.json`,
    `/data/${slug}/${pdfbnRaw}.map.json`,
    `${cafeRoot}/sources/${pdfbnRaw}.map.json`
  ];

  function normalizePara(p){
    const mm = (p||'').match(/^osf-(\d+)$/i);
    return mm ? `osf-${mm[1].padStart(3,"0")}` : (p||'');
  }
  const paraKey = normalizePara(paraRaw);

  let mapData=null, mapEntry=null, targetPage=1, pageSpan={from:1,to:1};
  for(const url of candidateMapUrls){
    try{ const res=await fetch(url,{cache:"no-store"}); if(res.ok){ mapData=await res.json(); break; } }catch(e){}
  }

  const firstPage = parseInt(pageQP || fromQP || "0", 10);
  const lastPage  = parseInt(toQP   || pageQP || fromQP || "0", 10);
  if (firstPage>0){
    targetPage = firstPage; pageSpan = {from:firstPage,to:Math.max(firstPage,lastPage||firstPage)};
  } else if (mapData && chapter && paraKey && mapData[chapter] && mapData[chapter][paraKey]) {
    mapEntry = mapData[chapter][paraKey];
    targetPage = mapEntry.from || 1;
    pageSpan = {from: mapEntry.from || 1, to: mapEntry.to || (mapEntry.from||1)};
  } else if (mapData?.meta?.starts?.[chapter]) {
    targetPage = mapData.meta.starts[chapter] || 1;
    pageSpan = {from: targetPage, to: targetPage};
  }

  async function tryLoadPdf(url){
    try{ const task=pdfjsLib.getDocument(url); const pdf=await task.promise; return {pdf,url}; }catch(e){ return null; }
  }
  let pdf=null, pdfUrl=null;
  for(const url of candidatePdfUrls){
    const r = await tryLoadPdf(url); if(r){ pdf=r.pdf; pdfUrl=r.url; break; }
  }
  if(!pdf){ alert("Failed to load PDF."); return; }
  $("#openOriginal").href = pdfUrl;
  $("#downloadPdf").href = pdfUrl;
  $("#downloadPdf").download = `${pdfbnRaw}.pdf`;

  // ---------- DOM ----------
  const thumbsEl = $("#thumbs");
  const viewer   = $("#viewer");
  const stage    = $("#stage");
  const canvas   = $("#pageCanvas");
  const overlay  = $("#overlay");
  const ctx      = canvas.getContext("2d");
  const ovx      = overlay.getContext("2d");
  const pageBadge= $("#pageBadge");
  const hlEl     = $(".hl-badge");

  const prevWrap = $("#prevStripWrap");
  const nextWrap = $("#nextStripWrap");
  const prevStrip= $("#prevStrip");
  const nextStrip= $("#nextStrip");

  const toggleContextBtn = $("#toggleContext");
  const toggleStackBtn   = $("#toggleStack");

  // ---------- state ----------
  let scale = 1.0; // auto-fit on first render
  let deviceScale = window.devicePixelRatio || 1;
  let current = clamp(targetPage, 1, pdf.numPages);
  let contextOn = false;
  let contextOnTop = false; // stacking state
  let firstRenderDone = false;

  const boxesByPage = new Map();
  function sizeOverlayToCanvas(){
    overlay.width  = canvas.width;
    overlay.height = canvas.height;
    overlay.style.width  = canvas.style.width;
    overlay.style.height = canvas.style.height;
    prevWrap.style.width = canvas.style.width;
    nextWrap.style.width = canvas.style.width;
  }
  function drawOverlay(pageNum){
    ovx.clearRect(0,0,overlay.width, overlay.height);
    const boxes = boxesByPage.get(pageNum) || [];
    ovx.globalAlpha = 0.25;
    for(const b of boxes){
      const x = Math.round(b.x * overlay.width);
      const y = Math.round(b.y * overlay.height);
      const w = Math.round(b.w * overlay.width);
      const h = Math.round(b.h * overlay.height);
      ovx.fillRect(x,y,w,h);
      ovx.strokeStyle = "rgba(31,111,235,0.85)";
      ovx.lineWidth = 2;
      ovx.strokeRect(x,y,w,h);
    }
    ovx.globalAlpha = 1;
  }
  function fitToWidthScale(page){
    const vp = page.getViewport({scale:1});
    const avail = viewer.clientWidth - 24;
    return Math.max(0.5, Math.min(3.0, avail / vp.width));
  }

  async function renderPage(pageNum, {repaintMain=true} = {}){
    const page = await pdf.getPage(pageNum);
    if (!firstRenderDone) scale = fitToWidthScale(page);

    const vpCSS   = page.getViewport({scale});
    const vpHiDPI = page.getViewport({scale: scale * deviceScale});

    if (repaintMain) {
      canvas.width  = vpHiDPI.width;
      canvas.height = vpHiDPI.height;
      canvas.style.width  = vpCSS.width + "px";
      canvas.style.height = vpCSS.height + "px";
      sizeOverlayToCanvas();
      await page.render({canvasContext: ctx, viewport: vpHiDPI}).promise;
      drawOverlay(pageNum);
    }

    hlEl.style.display = paraRaw ? "block" : "none";
    if (paraRaw) hlEl.textContent = `§ ${paraRaw} · p.${pageNum}`;
    document.querySelectorAll(".thumb").forEach(t=>t.classList.toggle("active", +t.dataset.p===pageNum));
    pageBadge.textContent = `p.${pageNum} / ${pdf.numPages}`;

    // show strips if toggled OR span across pages
    const shouldContext = (pageSpan.to > pageSpan.from);
    const wantStrips = contextOn || shouldContext;
    prevWrap.style.display = wantStrips ? "block" : "none";
    nextWrap.style.display = wantStrips ? "block" : "none";
    if (wantStrips) await renderStrips(pageNum);

    firstRenderDone = true;
  }

  // Render prev bottom (p−1) and current top (p) into strip canvases (cropped)
  async function renderStrips(pageNum){
    const frac = 0.22; // strip height fraction
    const stripCssW = parseFloat(canvas.style.width);
    const stripCssH = Math.max(60, Math.floor(parseFloat(canvas.style.height) * frac));
    prevWrap.style.height = stripCssH + "px";
    nextWrap.style.height = stripCssH + "px";

    async function renderCrop(targetPage, which){
      if (targetPage < 1 || targetPage > pdf.numPages) { // hide if out of bounds
        (which==="prev" ? prevWrap : nextWrap).style.display = "none";
        return;
      }
      (which==="prev" ? prevWrap : nextWrap).style.display = "block";

      const p = await pdf.getPage(targetPage);
      const s = scale;
      const vpHi  = p.getViewport({scale: s * deviceScale});

      // offscreen full page
      const off = document.createElement("canvas");
      off.width = vpHi.width; off.height = vpHi.height;
      await p.render({canvasContext: off.getContext("2d"), viewport: vpHi}).promise;

      // destination + crop rect
      const dst = (which === "prev") ? prevStrip : nextStrip;
      dst.width  = Math.floor(vpHi.width);
      dst.height = Math.floor(vpHi.height * frac);
      dst.style.width  = stripCssW + "px";
      dst.style.height = stripCssH + "px";

      const dctx = dst.getContext("2d");
      dctx.clearRect(0,0,dst.width,dst.height);

      if (which === "prev") {
        // bottom of p−1
        const sy = Math.floor(off.height * (1 - frac));
        const sh = Math.floor(off.height * frac);
        dctx.drawImage(off, 0, sy, off.width, sh, 0, 0, dst.width, dst.height);
      } else {
        // top of current p
        const sy = 0;
        const sh = Math.floor(off.height * frac);
        dctx.drawImage(off, 0, sy, off.width, sh, 0, 0, dst.width, dst.height);
      }
    }

    await renderCrop(pageNum - 1, "prev");
    await renderCrop(pageNum,     "next");
  }

  async function buildThumbs(){
    thumbsEl.innerHTML = "";
    const maxThumbs = Math.min(pdf.numPages, 126);
    for (let i=1;i<=maxThumbs;i++){
      const page = await pdf.getPage(i);
      const vp = page.getViewport({scale:0.25});
      const c = document.createElement("canvas");
      const dpr = deviceScale;
      c.width  = vp.width * dpr;
      c.height = vp.height * dpr;
      c.style.width = vp.width + "px";
      c.style.height= vp.height + "px";
      await page.render({canvasContext:c.getContext("2d"), viewport: page.getViewport({scale:0.25 * dpr})}).promise;
      const wrap = document.createElement("div");
      wrap.className = "thumb"; wrap.dataset.p = i;
      wrap.appendChild(c);
      wrap.onclick = ()=>{ current=i; renderPage(current); };
      thumbsEl.appendChild(wrap);
    }
    const anchor = document.querySelector(`.thumb[data-p="${current}"]`);
    if (anchor) {
      const y = Math.max(anchor.offsetTop - 80, 0);
      thumbsEl.scrollTo({top:y, behavior:"auto"});
      anchor.classList.add("active");
    }
  }

  // (Optional) runtime highlight boxes if map lacks boxes (kept from your previous version)
  async function computeBoxesIfNeeded(){
    if (mapEntry?.boxes?.length){
      for(const b of mapEntry.boxes){
        const arr = boxesByPage.get(b.page) || [];
        arr.push({ x:b.x, y:b.y, w:b.w, h:b.h });
        boxesByPage.set(b.page, arr);
      }
      return;
    }
    const want = norm(mapEntry?.quote || "");
    if (!want) return;

    for(let p=pageSpan.from; p<=pageSpan.to; p++){
      const page = await pdf.getPage(p);
      const vp = page.getViewport({scale:1});
      const tc = await page.getTextContent();
      const items = tc.items || [];
      let concat = ""; const ranges=[];
      for(let i=0;i<items.length;i++){
        const s = norm(items[i].str || ""); if (!s) continue;
        const start = concat.length;
        concat += (concat ? " " : "") + s;
        const end = concat.length;
        ranges.push({ start, end, itemIndex:i, s });
      }
      const idx = want ? concat.indexOf(want) : -1;
      if (idx === -1) continue;

      const idxEnd = idx + want.length;
      const use = [];
      for(const r of ranges){ const ov = !(r.end <= idx || r.start >= idxEnd); if (ov) use.push(r.itemIndex); }
      const lines = [];
      const epsY = 2.5;
      for(const k of use){
        const it = items[k]; if(!it || typeof it.transform === "undefined") continue;
        const tr = it.transform;
        const x = tr[4], y = tr[5];
        const w = it.width || Math.hypot(tr[0], tr[2]);
        const h = Math.abs(tr[3]) || 12;

        const nx = x / vp.width;
        const ny = 1 - ((y + h) / vp.height);
        const nw = Math.max(0, w / vp.width);
        const nh = Math.max(0.012, h / vp.height);

        let found=null;
        for(const L of lines){ if (Math.abs(L.y - ny) < (epsY / vp.height)) { found=L; break; } }
        if (!found) lines.push({ y: ny, x1: nx, x2: nx+nw, h: nh });
        else { found.x1=Math.min(found.x1,nx); found.x2=Math.max(found.x2,nx+nw); found.h=Math.max(found.h,nh); }
      }
      for(const L of lines){
        const arr = boxesByPage.get(p) || [];
        arr.push({ x:L.x1, y:L.y, w:Math.max(0.02,L.x2-L.x1), h:L.h });
        boxesByPage.set(p, arr);
      }
    }
  }

  // ---------- controls ----------
  $("#prevBtn").onclick   = ()=>{ if (current>1){ current--; renderPage(current);} };
  $("#nextBtn").onclick   = ()=>{ if (current<pdf.numPages){ current++; renderPage(current);} };
  $("#zoomOut").onclick   = ()=>{ scale = Math.max(0.5, scale-0.1); renderPage(current); };
  $("#zoomIn").onclick    = ()=>{ scale = Math.min(3.0,  scale+0.1); renderPage(current); };
  $("#resetZoom").onclick = ()=>{ scale = 1.0; renderPage(current); };
  $("#fitWidth").onclick  = async ()=> { const page = await pdf.getPage(current); scale = fitToWidthScale(page); renderPage(current); };
  toggleContextBtn.onclick = async ()=>{
    contextOn = !contextOn;
    toggleContextBtn.textContent = contextOn ? "Hide context" : "Context view";
    // show/hide strips; do not repaint main page
    if (contextOn) { prevWrap.style.display = "block"; nextWrap.style.display = "block"; await renderStrips(current); }
    else { prevWrap.style.display = "none"; nextWrap.style.display = "none"; }
  };
  toggleStackBtn.onclick = ()=>{
    contextOnTop = !contextOnTop;
    stage.classList.toggle('context-front', contextOnTop);
    toggleStackBtn.textContent = contextOnTop ? "Preview on top" : "Context on top";
  };

  // ---------- boot ----------
  await computeBoxesIfNeeded();
  await renderPage(current);  // auto fit-width here
  buildThumbs();
  if (pageSpan.from !== current){ current = pageSpan.from; await renderPage(current); }

  window.addEventListener('resize', debounce(async ()=>{
    const page = await pdf.getPage(current);
    const newScale = fitToWidthScale(page);
    if (Math.abs(newScale - scale) > 0.01){
      scale = newScale;
      await renderPage(current);
      if (prevWrap.style.display === "block" || nextWrap.style.display === "block") await renderStrips(current);
    }
  }, 150));
})();
</script>
</body>
</html>


