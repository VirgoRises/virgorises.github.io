<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Source document</title>
  <link rel="stylesheet" href="/css/bundle.css"/>
  <style>
    :root { --pad: 14px; }
    body { margin: 0; background: #0d1117; color: #c9d1d9; }
    .wrap { max-width: 1200px; margin: 0 auto; padding: var(--pad); }
    .bar { display: flex; align-items: center; gap: .5rem; margin-bottom: 10px; }
    .bar .spacer { flex: 1; }
    .btn { padding: 6px 10px; border-radius: 8px; background: #1f2937; border: 1px solid #2a2f3a; color: #c9d1d9; }
    .btn:hover { background: #263244; }
    #docTitle { font-weight: 600; margin-left: .25rem; }
    #linkNote { color: #8b949e; font-size: .9rem; margin: 6px 2px 12px; }
    .viewerShell { display: grid; grid-template-columns: 260px 1fr; gap: 12px; }
    .side, .main { border: 1px solid #2a2f3a; border-radius: 12px; background: #0f1420; padding: 12px; }
    .controls { display: flex; gap: 8px; align-items: center; margin-bottom: 8px; }
    .pg { min-width: 6ch; text-align: center; }
    canvas { width: 100%; height: auto; display: block; background: #111; }
    .thumbs { display: flex; flex-direction: column; gap: 8px; max-height: calc(100vh - 210px); overflow: auto; }
    .thumbs canvas { width: 100%; border: 1px solid #243041; border-radius: 8px; cursor: pointer; background:#0b0f16; }
    .thumb.active { box-shadow: 0 0 0 2px #2563eb inset; }
    .hr { height: 1px; background: #1f2937; margin: 8px 0; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
  <script>pdfjsLib.GlobalWorkerOptions.workerSrc="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js";</script>
</head>
<body>
<div class="wrap">
  <div class="bar">
    <button id="backBtn" class="btn">&larr; Back</button>
    <span id="docTitle"></span>
    <span class="spacer"></span>
    <a id="openRaw" class="btn" target="_blank" rel="noopener">Open original</a>
    <a id="downloadBtn" class="btn" download>Download</a>
  </div>
  <div id="linkNote"></div>

  <div class="viewerShell">
    <div class="side">
      <div class="controls">
        <button id="prevBtn" class="btn">Prev</button>
        <span id="pgInfo" class="pg"></span>
        <button id="nextBtn" class="btn">Next</button>
        <div class="spacer"></div>
        <button id="zoomOut" class="btn">−</button>
        <button id="zoomIn" class="btn">+</button>
      </div>
      <div class="hr"></div>
      <div id="thumbs" class="thumbs"></div>
    </div>
    <div class="main">
      <canvas id="pageCanvas"></canvas>
    </div>
  </div>
</div>

<script>
(async function () {
  // ---------- URL & helpers ----------
  const qs = new URLSearchParams(location.search);
  const base   = (qs.get('pdf') || 'Old_main').replace(/\.pdf$/i, '');
  const paraRaw= qs.get('para') || '';
  const chapterParam = qs.get('chapter') || '';
  const ret    = qs.get('return') ? decodeURIComponent(qs.get('return')) : '';
  const fromQ  = parseInt(qs.get('from')||'', 10);

  const $  = s => document.querySelector(s);
  const $$ = s => [...document.querySelectorAll(s)];

  $('#docTitle').textContent = base + '.pdf';
  if (paraRaw) $('#linkNote').textContent = `Linked from ${paraRaw}${chapterParam ? " — " + decodeURIComponent(chapterParam) : ""}`;

  const parts = location.pathname.split('/').filter(Boolean);  // /cafes/{slug}/source.html
  const slug  = parts[1] || 'zeta-zero-cafe';
  const cafe  = `/cafes/${slug}`;

  const normPath  = s => (s||"").replace(/\\/g,"/").replace(/^\/+|\/+$/g,"").toLowerCase();
  const onlyFile  = s => normPath(s).split("/").slice(-1)[0];
  const dropNotebook = s => normPath(s).replace(/^notebook\//,"");

  function normParaKey(p) {
    const m = String(p||'').match(/^osf-(\d+)$/i);
    return m ? `osf-${parseInt(m[1],10)}` : String(p||'');
  }
  const paraKey = normParaKey(paraRaw);
  const paraNum = (() => {
    const m = paraKey.match(/^osf-(\d+)$/i); return m ? parseInt(m[1],10) : null;
  })();

  const chapterFull   = decodeURIComponent(chapterParam || '');
  const chapterKeys = [ normPath(chapterFull), dropNotebook(chapterFull), onlyFile(chapterFull) ].filter(Boolean);

  // ---------- map loading ----------
  async function fetchJSON(url) {
    const r = await fetch(url, { cache:'no-store' });
    if (!r.ok) throw new Error('HTTP '+r.status);
    return r.json();
  }
  async function loadMap() {
    const candidates = [
      `/data/cafes/${slug}/sources/${base}.map.json`,
      `/cafes/${slug}/sources/${base}.map.json`,
      `/cafes/${slug}/data/sources/${base}.map.json`,
      `/data/cafes/${slug}/${base}.map.json`,
      `/data/sources/${base}.map.json`,
      `/sources/${base}.map.json`,
      `/data/${base}.map.json`
    ];
    for (const u of candidates) {
      try {
        return await fetchJSON(u + `?v=${Date.now()}`);
      } catch(_) {}
    }
    return null;
  }

  function pickChapterBlock(map) {
    // Prefer map.chapters[...] if present, else tolerate root keyed by chapter
    const chs = map?.chapters;
    if (chs && typeof chs === 'object') {
      for (const k of chapterKeys) {
        if (chs[k]) return { block: chs[k], key: k, container: 'chapters' };
      }
    }
    // root-level chapter blocks
    for (const k of chapterKeys) {
      if (map && map[k] && typeof map[k] === 'object') return { block: map[k], key: k, container: 'root' };
    }
    // nothing found -> empty
    return { block: null, key: chapterKeys[0] || '', container: null };
  }

  function pageFromEntry(entry) {
    if (entry == null) return undefined;
    if (typeof entry === 'number') return entry;
    const cand = [entry.from, entry.pdf_from, entry.page, entry.start, entry.p, entry.to];
    for (const v of cand) {
      const n = parseInt(v,10);
      if (Number.isFinite(n) && n > 0) return n;
    }
    return undefined;
  }

  function computeAbsolute(meta, chapterKey, rawPage) {
    const relative = !!meta?.relative;
    const starts   = meta?.starts || meta?.chapterStarts || {};
    const offsets  = meta?.offsets || {};
    const globalOffset = parseInt(meta?.offset||0,10) || 0;

    let abs = parseInt(rawPage,10);
    if (relative) {
      // interpret as 1-based within chapter
      const startKey = chapterKeys.find(k => Object.prototype.hasOwnProperty.call(starts, k));
      const start = startKey ? parseInt(starts[startKey],10) : 1;
      abs = start + (abs - 1);
    }
    const offKey = chapterKeys.find(k => Object.prototype.hasOwnProperty.call(offsets, k));
    if (offKey) abs += parseInt(offsets[offKey],10) || 0;
    abs += globalOffset;
    return abs;
  }

  function getMappedPage(map) {
    if (!map) return null;

    // ?from= override
    if (Number.isFinite(fromQ) && fromQ > 0) return fromQ;

    const meta = map.meta || {};
    const starts = map.starts || meta.starts || meta.chapterStarts || {};
    // Chapter start fallback if nothing else
    const chapterStart = (() => {
      const k = chapterKeys.find(kk => Object.prototype.hasOwnProperty.call(starts, kk));
      return k ? parseInt(starts[k],10) : 1;
    })();

    const { block, key: foundKey } = pickChapterBlock(map);

    // If there is no chapter block at all, fall back to chapter start (plus offsets)
    if (!block || typeof block !== 'object') {
      return computeAbsolute(meta, foundKey, chapterStart);
    }

    // Try exact match first
    const exact = block[paraKey] ?? block[String(paraNum)] ?? null;
    const exactPage = pageFromEntry(exact);
    if (Number.isFinite(exactPage)) {
      return computeAbsolute(meta, foundKey, exactPage);
    }

    // Numeric nearest-previous *within this chapter block* (no spillover)
    const entries = Object.keys(block)
      .map(k => ({ n: parseInt((k.match(/^osf-(\d+)$/i)||[])[1],10), k }))
      .filter(e => Number.isFinite(e.n))
      .sort((a,b)=>a.n-b.n);

    if (Number.isFinite(paraNum)) {
      const prev = entries.filter(e => e.n <= paraNum).pop();
      if (prev) {
        const p = pageFromEntry(block[prev.k]);
        if (Number.isFinite(p)) return computeAbsolute(meta, foundKey, p);
      }
    }

    // Fallback to explicit chapter start
    return computeAbsolute(meta, foundKey, chapterStart);
  }

  // ---------- find the PDF ----------
  async function firstReachable(urls) {
    for (const u of urls) {
      try {
        const h = await fetch(u, { method:'HEAD', cache:'no-store' });
        if (h.ok) return u;
      } catch(_) {}
    }
    return null;
  }
  const pdfUrl = await firstReachable([
    `${cafe}/source/${base}.pdf`,
    `${cafe}/sources/${base}.pdf`,
    `${cafe}/pdf/${base}.pdf`,
    `${cafe}/${base}.pdf`,
  ]);
  if (!pdfUrl) {
    document.querySelector('.main').innerHTML = `<div style="padding:12px">Could not find <b>${base}.pdf</b>.</div>`;
    $('#openRaw').style.display = 'none';
    $('#downloadBtn').style.display = 'none';
    return;
  }
  $('#openRaw').href = pdfUrl;
  $('#downloadBtn').href = pdfUrl;
  $('#downloadBtn').setAttribute('download', base + '.pdf');

  // ---------- load PDF via Blob ----------
  const bytes = await fetch(pdfUrl, { cache:'no-store' }).then(r => r.arrayBuffer());
  const pdf   = await pdfjsLib.getDocument({ data: bytes }).promise;

  // ---------- resolve start page from map ----------
  const map = await loadMap();
  let targetPage = getMappedPage(map) || 1;
  targetPage = Math.min(Math.max(targetPage, 1), pdf.numPages);

  // ---------- viewer ----------
  let currentPage = targetPage;
  let scale = 1.3;

  const canvas = $('#pageCanvas');
  const ctx    = canvas.getContext('2d');
  const thumbs = $('#thumbs');

  function highlightThumb(i){
    $$('.thumb.active', thumbs).forEach(el => el.classList.remove('active'));
    const el = thumbs.querySelector(`.thumb[data-page="${i}"]`);
    if (el) el.classList.add('active');
  }
  function scrollThumb(i, smooth=true){
    const el = thumbs.querySelector(`.thumb[data-page="${i}"]`);
    if (!el) return;
    thumbs.scrollTo({ top: Math.max(0, el.offsetTop - 8), behavior: smooth ? 'smooth' : 'instant' });
  }

  async function renderPage(num, opts={smooth:true}) {
    const page = await pdf.getPage(num);
    const vp = page.getViewport({ scale });
    canvas.width  = vp.width;
    canvas.height = vp.height;
    await page.render({ canvasContext: ctx, viewport: vp }).promise;
    $('#pgInfo').textContent = `${currentPage} / ${pdf.numPages}`;
    highlightThumb(num);
    scrollThumb(num, opts.smooth);
  }

  $('#prevBtn').onclick = async ()=>{ if (currentPage>1) { currentPage--; await renderPage(currentPage); } };
  $('#nextBtn').onclick = async ()=>{ if (currentPage<pdf.numPages){ currentPage++; await renderPage(currentPage); } };
  $('#zoomIn').onclick  = async ()=>{ scale = Math.min(scale*1.15, 4);  await renderPage(currentPage, {smooth:false}); };
  $('#zoomOut').onclick = async ()=>{ scale = Math.max(scale/1.15, .5); await renderPage(currentPage, {smooth:false}); };

  // thumbnails (lazy)
  const thumbObserver = new IntersectionObserver(async (entries)=>{
    for (const entry of entries){
      if (!entry.isIntersecting) continue;
      const c = entry.target;
      if (c.dataset.rendered === '1') continue;
      const i = +c.dataset.page;
      try{
        const p  = await pdf.getPage(i);
        const vp = p.getViewport({ scale: 0.22 });
        c.width  = vp.width;
        c.height = vp.height;
        await p.render({ canvasContext: c.getContext('2d'), viewport: vp }).promise;
        c.dataset.rendered = '1';
      }catch(err){ console.warn('Thumb render failed', i, err); }
    }
  }, { root: thumbs, rootMargin: '300px 0px', threshold: 0.01 });

  for (let i=1;i<=pdf.numPages;i++){
    const c = document.createElement('canvas');
    c.className   = 'thumb';
    c.dataset.page= String(i);
    c.title       = `Page ${i}`;
    c.onclick     = async ()=>{ currentPage = i; await renderPage(currentPage); };
    thumbs.appendChild(c);
    thumbObserver.observe(c);
  }

  // initial render; snap thumb immediately
  await renderPage(currentPage, {smooth:false});

  // Back
  $('#backBtn').onclick = (e) => { e.preventDefault(); if (ret) location.href = ret; else history.back(); };
})();
</script>
</body>
</html>
