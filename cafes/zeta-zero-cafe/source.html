<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Source document</title>
  <link rel="stylesheet" href="/css/10-components/research-office.css">
  <style>
    body{background:#0d1117;color:#e6edf3;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    .wrap{max-width:1200px;margin:0 auto;padding:16px}
    .bar{display:flex;gap:8px;align-items:center;margin-bottom:12px;flex-wrap:wrap}
    .btn{background:#161b22;border:1px solid #30363d;padding:6px 10px;border-radius:8px;color:#e6edf3;text-decoration:none;cursor:pointer}
    .btn:hover{background:#1f242d}
    .badge{font-size:.8rem;opacity:.85;border:1px solid #30363d;border-radius:999px;padding:2px 8px}

    .cols{display:grid;grid-template-columns:280px 1fr;gap:16px}
    .thumbs{background:#0b0f14;border:1px solid #30363d;border-radius:12px;padding:12px;height:70vh;overflow:auto}

    .viewer{background:#0b0f14;border:1px solid #30363d;border-radius:12px;padding:12px;height:70vh;overflow:auto;position:relative}
    #stage{position:relative}
    #pageCanvas{display:block;margin:0 auto;position:relative;z-index:2}
    #overlay{position:absolute;left:0;top:0;pointer-events:none;z-index:3}
    .hl-badge{position:absolute;left:8px;top:8px;background:#1f6feb22;border:1px solid #1f6feb;border-radius:6px;padding:2px 6px;font-size:.8rem;z-index:4}

    /* Context strips (p−1 bottom at top edge, p top at bottom edge) */
    .strip{position:absolute;left:50%;transform:translateX(-50%);width:100%;pointer-events:none;border-radius:8px;box-shadow:0 2px 10px rgba(0,0,0,.35)}
    #prevStripWrap{top:0}
    #nextStripWrap{bottom:0}
    .strip .label{position:absolute;left:8px;top:6px;font-size:.75rem;opacity:.85;background:#0b0f14d0;border:1px solid #30363d;padding:2px 6px;border-radius:6px;pointer-events:auto}
    .strip canvas{display:block;width:100%;height:auto;border:1px dashed #30363d;border-radius:8px;background:#0b0f14}

    .controls{display:flex;gap:8px;margin-top:8px;flex-wrap:wrap}
    .thumb{margin:8px 0;border:1px solid #30363d;border-radius:8px;overflow:hidden;cursor:pointer}
    .thumb.active{box-shadow:0 0 0 2px #1f6feb inset}
    .thumb canvas{width:100% !important;height:auto !important}
    .sep{opacity:.4}
  </style>
  <script src="https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
</head>
<body>
  <div class="wrap">
    <div class="bar">
      <a id="backBtn" class="btn" href="javascript:history.back()">← Back</a>
      <span id="pdfName" class="btn badge"></span>
      <span class="btn badge">Linked from <span id="fromTag">—</span></span>
      <span class="sep">|</span>
      <a id="openOriginal" class="btn" target="_blank" rel="noopener">Open original</a>
      <a id="downloadPdf" class="btn" download>Download</a>
      <span class="sep">|</span>
      <span id="pageBadge" class="btn badge">p.— / —</span>
      <button class="btn" id="toggleStack">Context on top</button>
    </div>

    <div class="cols">
      <div class="thumbs" id="thumbs"></div>

      <div class="viewer" id="viewer">
        <div class="hl-badge" id="hl" style="display:none"></div>

        <div id="stage">
          <canvas id="pageCanvas"></canvas>
          <canvas id="overlay"></canvas>

          <!-- Context strips overlay (always visible) -->
          <div id="prevStripWrap" class="strip">
            <span class="label">Prev (p−1) — bottom</span>
            <canvas id="prevStrip"></canvas>
          </div>
          <div id="nextStripWrap" class="strip">
            <span class="label">Current (p) — top</span>
            <canvas id="nextStrip"></canvas>
          </div>
        </div>
      </div>
    </div>

    <div class="controls">
      <button class="btn" id="prevBtn">Prev</button>
      <button class="btn" id="nextBtn">Next</button>
      <button class="btn" id="zoomOut">−</button>
      <button class="btn" id="zoomIn">+</button>
      <button class="btn" id="fitWidth">Fit width</button>
      <button class="btn" id="resetZoom">100%</button>
    </div>
  </div>

<script>
(async () => {
  if (!window.pdfjsLib) { alert("PDF.js failed to load."); return; }
  const pdfjsLib = window.pdfjsLib;
  pdfjsLib.GlobalWorkerOptions.workerSrc = "https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.worker.min.js";

  // ---------- helpers ----------
  const $ = sel => document.querySelector(sel);
  const clamp=(n,lo,hi)=> Math.max(lo, Math.min(hi,n));
  const debounce=(fn,ms=120)=>{ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); }; };
  const norm = s => (s||'').toLowerCase().replace(/\s+/g,' ').replace(/[\u00ad\u200b]/g,'').trim();

  const u = new URL(location.href);
  const pdfbnRaw = (u.searchParams.get("pdf") || "Old_main").replace(/\.pdf$/i,"");
  const paraRaw  = u.searchParams.get("para") || "";
  const chapter  = decodeURIComponent(u.searchParams.get("chapter") || "");
  const returnUrl= u.searchParams.get("return") || document.referrer || "/";
  const fromQP   = u.searchParams.get("from");
  const toQP     = u.searchParams.get("to");
  const pageQP   = u.searchParams.get("page");

  const m = location.pathname.match(/^\/cafes\/([^\/]+)/);
  const slug = m ? m[1] : "zeta-zero-cafe";
  const cafeRoot = `/cafes/${slug}`;

  $("#pdfName").textContent = `${pdfbnRaw}.pdf`;
  $("#fromTag").textContent = paraRaw || "—";
  $("#backBtn").onclick = (e)=>{ e.preventDefault(); if (returnUrl) location.href = returnUrl; else history.back(); };

  const pdfUrls = [
    `${cafeRoot}/sources/${pdfbnRaw}.pdf`,
    `${cafeRoot}/pdf/${pdfbnRaw}.pdf`,
    `${cafeRoot}/${pdfbnRaw}.pdf`,
    `/sources/${pdfbnRaw}.pdf`,
    `/pdf/${pdfbnRaw}.pdf`
  ];
  const mapUrls = [
    `/data/cafes/${slug}/sources/${pdfbnRaw}.map.json`,
    `/data/cafes/${slug}/${pdfbnRaw}.map.json`,
    `/data/${slug}/${pdfbnRaw}.map.json`,
    `${cafeRoot}/sources/${pdfbnRaw}.map.json`
  ];

  function normalizePara(p){
    const mm = (p||'').match(/^osf-(\d+)$/i);
    return mm ? `osf-${mm[1].padStart(3,"0")}` : (p||'');
  }
  const paraKey = normalizePara(paraRaw);

  let mapData=null, mapEntry=null, targetPage=1, pageSpan={from:1,to:1};
  for(const url of mapUrls){ try{ const r=await fetch(url,{cache:"no-store"}); if(r.ok){ mapData=await r.json(); break; } }catch{} }

  const firstPage = parseInt(pageQP || fromQP || "0", 10);
  const lastPage  = parseInt(toQP   || pageQP || fromQP || "0", 10);
  if (firstPage>0){
    targetPage = firstPage; pageSpan = {from:firstPage,to:Math.max(firstPage,lastPage||firstPage)};
  } else if (mapData && chapter && paraKey && mapData[chapter]?.[paraKey]) {
    mapEntry = mapData[chapter][paraKey];
    targetPage = mapEntry.from || 1;
    pageSpan = {from: mapEntry.from || 1, to: mapEntry.to || (mapEntry.from||1)};
  } else if (mapData?.meta?.starts?.[chapter]) {
    targetPage = mapData.meta.starts[chapter] || 1;
    pageSpan = {from: targetPage, to: targetPage};
  }

  async function tryPdf(url){ try{ const t=pdfjsLib.getDocument(url); const pdf=await t.promise; return {pdf,url}; }catch{ return null; } }
  let pdf=null, pdfUrl=null;
  for(const u of pdfUrls){ const r=await tryPdf(u); if(r){ pdf=r.pdf; pdfUrl=r.url; break; } }
  if(!pdf){ alert("Failed to load PDF."); return; }
  $("#openOriginal").href = pdfUrl;
  $("#downloadPdf").href = pdfUrl;
  $("#downloadPdf").download = `${pdfbnRaw}.pdf`;

  // ---------- DOM & state ----------
  const thumbsEl = $("#thumbs");
  const viewer   = $("#viewer");
  const stage    = $("#stage");
  const canvas   = $("#pageCanvas");
  const overlay  = $("#overlay");
  const ctx      = canvas.getContext("2d");
  const ovx      = overlay.getContext("2d");
  const pageBadge= $("#pageBadge");
  const hlEl     = $(".hl-badge");

  const prevWrap = $("#prevStripWrap");
  const nextWrap = $("#nextStripWrap");
  const prevStrip= $("#prevStrip");
  const nextStrip= $("#nextStrip");
  const toggleStackBtn = $("#toggleStack");

  let scale = 1.0;
  let dpr = window.devicePixelRatio || 1;
  let current = Math.max(1, Math.min(targetPage, pdf.numPages));
  let contextOnTop = false;
  let firstRenderDone = false;
  const boxesByPage = new Map();

  function applyStacking(){
    // explicit z order: strips ⇄ overlay ⇄ canvas
    prevWrap.style.zIndex = contextOnTop ? "6" : "1";
    nextWrap.style.zIndex = contextOnTop ? "6" : "1";
    overlay.style.zIndex  = contextOnTop ? "5" : "3";
    canvas.style.zIndex   = "2";
    toggleStackBtn.textContent = contextOnTop ? "Preview on top" : "Context on top";
  }

  function sizeOverlay(){
    overlay.width  = canvas.width;
    overlay.height = canvas.height;
    overlay.style.width  = canvas.style.width;
    overlay.style.height = canvas.style.height;
    prevWrap.style.width = canvas.style.width;
    nextWrap.style.width = canvas.style.width;
    // each strip is exactly half of the page height (CSS)
    const halfCss = Math.floor(parseFloat(canvas.style.height) * 0.5);
    prevWrap.style.height = halfCss + "px";
    nextWrap.style.height = halfCss + "px";
  }

  function drawOverlay(pageNum){
    ovx.clearRect(0,0,overlay.width, overlay.height);
    const boxes = boxesByPage.get(pageNum) || [];
    ovx.globalAlpha = 0.25;
    for(const b of boxes){
      const x = Math.round(b.x * overlay.width);
      const y = Math.round(b.y * overlay.height);
      const w = Math.round(b.w * overlay.width);
      const h = Math.round(b.h * overlay.height);
      ovx.fillRect(x,y,w,h);
      ovx.strokeStyle = "rgba(31,111,235,0.85)";
      ovx.lineWidth = 2;
      ovx.strokeRect(x,y,w,h);
    }
    ovx.globalAlpha = 1;
  }

  function fitToWidthScale(page){
    const vp1 = page.getViewport({scale:1});
    const avail = viewer.clientWidth - 24;
    return Math.max(0.5, Math.min(3.0, avail / vp1.width));
  }

  async function renderPage(pageNum, {repaintMain=true}={}){
    const page = await pdf.getPage(pageNum);
    if (!firstRenderDone) scale = fitToWidthScale(page);

    const vpCss = page.getViewport({scale});
    const vpHi  = page.getViewport({scale: scale * dpr});

    if (repaintMain){
      canvas.width  = vpHi.width;
      canvas.height = vpHi.height;
      canvas.style.width  = vpCss.width + "px";
      canvas.style.height = vpCss.height + "px";
      sizeOverlay();
      await page.render({canvasContext: ctx, viewport: vpHi}).promise;
      drawOverlay(pageNum);
    }

    hlEl.style.display = paraRaw ? "block" : "none";
    if (paraRaw) hlEl.textContent = `§ ${paraRaw} · p.${pageNum}`;
    document.querySelectorAll(".thumb").forEach(t=>t.classList.toggle("active", +t.dataset.p===pageNum));
    pageBadge.textContent = `p.${pageNum} / ${pdf.numPages}`;

    await renderStrips(pageNum); // always visible
    firstRenderDone = true;
  }

  // Render strips: exactly 50% each (bottom half of p−1, top half of p)
  async function renderStrips(pageNum){
    const prevPageNo = pageNum - 1;
    const currPageNo = pageNum;

    async function halfTo(targetPage, which){
      const wrap = which==="prev" ? prevWrap : nextWrap;
      if (targetPage < 1 || targetPage > pdf.numPages){ wrap.style.display="none"; return; }
      wrap.style.display="block";

      const page = await pdf.getPage(targetPage);
      const vpHi = page.getViewport({scale: scale * dpr});

      const off = document.createElement("canvas");
      off.width = vpHi.width; off.height = vpHi.height;
      await page.render({canvasContext: off.getContext("2d"), viewport: vpHi}).promise;

      const dst = which==="prev" ? prevStrip : nextStrip;
      dst.width  = vpHi.width;
      dst.height = Math.floor(vpHi.height * 0.5); // half page
      dst.style.width  = canvas.style.width;
      dst.style.height = Math.floor(parseFloat(canvas.style.height) * 0.5) + "px";

      const dctx = dst.getContext("2d");
      dctx.clearRect(0,0,dst.width,dst.height);

      if (which==="prev"){
        // bottom half of previous page
        const sy = Math.floor(vpHi.height * 0.5);
        const sh = vpHi.height - sy;
        dctx.drawImage(off, 0, sy, vpHi.width, sh, 0, 0, dst.width, dst.height);
      }else{
        // top half of current page
        const sy = 0, sh = Math.floor(vpHi.height * 0.5);
        dctx.drawImage(off, 0, sy, vpHi.width, sh, 0, 0, dst.width, dst.height);
      }
    }

    await halfTo(prevPageNo, "prev");
    await halfTo(currPageNo, "next");
  }

  async function buildThumbs(){
    thumbsEl.innerHTML = "";
    const n = Math.min(pdf.numPages, 126);
    for (let i=1;i<=n;i++){
      const p = await pdf.getPage(i);
      const vp = p.getViewport({scale:0.25});
      const c = document.createElement("canvas");
      const dd = dpr;
      c.width  = vp.width * dd;
      c.height = vp.height * dd;
      c.style.width = vp.width + "px";
      c.style.height= vp.height + "px";
      await p.render({canvasContext:c.getContext("2d"), viewport: p.getViewport({scale:0.25 * dd})}).promise;
      const w = document.createElement("div");
      w.className="thumb"; w.dataset.p=i;
      w.appendChild(c);
      w.onclick=()=>{ current=i; renderPage(current); };
      thumbsEl.appendChild(w);
    }
    const a = document.querySelector(`.thumb[data-p="${current}"]`);
    if (a){ thumbsEl.scrollTo({top: Math.max(a.offsetTop-80,0), behavior:"auto"}); a.classList.add("active"); }
  }

  // Optional: quote-based highlight boxes (unchanged)
  async function computeBoxesIfNeeded(){
    if (mapEntry?.boxes?.length){
      for(const b of mapEntry.boxes){
        const arr = boxesByPage.get(b.page) || [];
        arr.push({ x:b.x, y:b.y, w:b.w, h:b.h });
        boxesByPage.set(b.page, arr);
      }
      return;
    }
    const want = norm(mapEntry?.quote || ""); if (!want) return;
    for(let p=pageSpan.from; p<=pageSpan.to; p++){
      const page = await pdf.getPage(p);
      const vp = page.getViewport({scale:1});
      const tc = await page.getTextContent();
      const items = tc.items || [];
      let concat=""; const ranges=[];
      for(let i=0;i<items.length;i++){
        const s = norm(items[i].str||""); if (!s) continue;
        const start = concat.length; concat += (concat?" ":"")+s; const end=concat.length;
        ranges.push({start,end,itemIndex:i,s});
      }
      const idx = want? concat.indexOf(want): -1; if (idx===-1) continue;
      const idxEnd = idx + want.length;
      const use=[]; for(const r of ranges){ if(!(r.end<=idx || r.start>=idxEnd)) use.push(r.itemIndex); }
      const lines=[]; const epsY=2.5;
      for(const k of use){
        const it=items[k]; if(!it || !it.transform) continue;
        const tr=it.transform, x=tr[4], y=tr[5], w=it.width||Math.hypot(tr[0],tr[2]), h=Math.abs(tr[3])||12;
        const nx=x/vp.width, ny=1-((y+h)/vp.height), nw=w/vp.width, nh=Math.max(0.012,h/vp.height);
        let L=null; for(const ln of lines){ if (Math.abs(ln.y-ny)<(epsY/vp.height)){L=ln;break;} }
        if(!L) lines.push({y:ny,x1:nx,x2:nx+nw,h:nh}); else {L.x1=Math.min(L.x1,nx); L.x2=Math.max(L.x2,nx+nw); L.h=Math.max(L.h,nh);}
      }
      for(const L of lines){
        const arr = boxesByPage.get(p) || [];
        arr.push({x:L.x1,y:L.y,w:Math.max(0.02,L.x2-L.x1),h:L.h});
        boxesByPage.set(p,arr);
      }
    }
  }

  // controls
  $("#prevBtn").onclick=()=>{ if(current>1){ current--; renderPage(current);} };
  $("#nextBtn").onclick=()=>{ if(current<pdf.numPages){ current++; renderPage(current);} };
  $("#zoomOut").onclick=()=>{ scale=Math.max(0.5,scale-0.1); renderPage(current); };
  $("#zoomIn").onclick=()=>{ scale=Math.min(3.0,scale+0.1); renderPage(current); };
  $("#resetZoom").onclick=()=>{ scale=1.0; renderPage(current); };
  $("#fitWidth").onclick=async()=>{ const p=await pdf.getPage(current); scale=fitToWidthScale(p); renderPage(current); };

  // single stacking toggle
  $("#toggleStack").onclick=()=>{ contextOnTop=!contextOnTop; applyStacking(); };

  // boot
  applyStacking();
  await computeBoxesIfNeeded();
  await renderPage(current); // auto fit width
  buildThumbs();
  if (pageSpan.from!==current){ current=pageSpan.from; await renderPage(current); }

  window.addEventListener('resize', debounce(async ()=>{
    const p=await pdf.getPage(current);
    const s=fitToWidthScale(p);
    if(Math.abs(s-scale)>0.01){ scale=s; await renderPage(current); }
  },150));
})();
</script>
</body>
</html>
