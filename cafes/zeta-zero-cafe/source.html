<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Source document</title>
  <link rel="stylesheet" href="/css/bundle.css"/>
  <style>
    :root { --pad: 14px; }
    body { margin: 0; background: #0d1117; color: #c9d1d9; }
    .wrap { max-width: 1200px; margin: 0 auto; padding: var(--pad); }
    .bar { display: flex; align-items: center; gap: .5rem; margin-bottom: 10px; }
    .bar .spacer { flex: 1; }
    .btn { padding: 6px 10px; border-radius: 8px; background: #1f2937; border: 1px solid #2a2f3a; color: #c9d1d9; }
    .btn:hover { background: #263244; }
    #docTitle { font-weight: 600; margin-left: .25rem; }
    #linkNote { color: #8b949e; font-size: .9rem; margin: 6px 2px 12px; }
    .viewerShell { display: grid; grid-template-columns: 260px 1fr; gap: 12px; }
    .side, .main { border: 1px solid #2a2f3a; border-radius: 12px; background: #0f1420; padding: 12px; }
    .controls { display: flex; gap: 8px; align-items: center; margin-bottom: 8px; }
    .pg { min-width: 6ch; text-align: center; }
    canvas { width: 100%; height: auto; display: block; background: #111; }
    .thumbs { display: flex; flex-direction: column; gap: 8px; max-height: calc(100vh - 210px); overflow: auto; }
    .thumbs canvas { width: 100%; border: 1px solid #243041; border-radius: 8px; cursor: pointer; background:#0b0f16; }
    .thumb.active { box-shadow: 0 0 0 2px #2563eb inset; }
    .hr { height: 1px; background: #1f2937; margin: 8px 0; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
  <script>pdfjsLib.GlobalWorkerOptions.workerSrc="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js";</script>
</head>
<body>
<div class="wrap">
  <div class="bar">
    <button id="backBtn" class="btn">&larr; Back</button>
    <span id="docTitle"></span>
    <span class="spacer"></span>
    <a id="openRaw" class="btn" target="_blank" rel="noopener">Open original</a>
    <a id="downloadBtn" class="btn" download>Download</a>
  </div>
  <div id="linkNote"></div>

  <div class="viewerShell">
    <div class="side">
      <div class="controls">
        <button id="prevBtn" class="btn">Prev</button>
        <span id="pgInfo" class="pg"></span>
        <button id="nextBtn" class="btn">Next</button>
        <div class="spacer"></div>
        <button id="zoomOut" class="btn">−</button>
        <button id="zoomIn" class="btn">+</button>
      </div>
      <div class="hr"></div>
      <div id="thumbs" class="thumbs"></div>
    </div>
    <div class="main">
      <canvas id="pageCanvas"></canvas>
    </div>
  </div>
</div>

<script>
(async function () {
  const qs = new URLSearchParams(location.search);
  const base   = (qs.get('pdf') || 'Old_main').replace(/\.pdf$/i, '');
  const paraId = qs.get('para') || '';             // "osf-17"
  const chapter= qs.get('chapter') || '';          // "notebook/…html"
  const ret    = qs.get('return') ? decodeURIComponent(qs.get('return')) : '';
  const fromQ  = parseInt(qs.get('from')||'', 10);

  const $  = s => document.querySelector(s);
  const $$ = s => [...document.querySelectorAll(s)];
  $('#docTitle').textContent = base + '.pdf';
  if (paraId) $('#linkNote').textContent = `Linked from ${paraId}${chapter ? " — " + chapter : ""}`;

  const parts = location.pathname.split('/').filter(Boolean);
  const slug  = parts[1] || 'zeta-zero-cafe';     // /cafes/{slug}/source.html
  const cafe  = `/cafes/${slug}`;

  // helpers
  const norm  = s => (s||"").replace(/\\/g,"/").replace(/^\/+|\/+$/g,"").toLowerCase();
  const onlyFile = s => norm(s).split("/").slice(-1)[0];
  const dropNotebook = s => norm(s).replace(/^notebook\//,"");

  async function firstReachable(urls) {
    for (const u of urls) {
      try { const h = await fetch(u, { method:'HEAD', cache:'no-store' }); if (h.ok) return u; } catch(_) {}
    }
    return null;
  }

  async function loadMap() {
    const paths = [
      `/data/cafes/${slug}/sources/${base}.map.json`,
      `/cafes/${slug}/sources/${base}.map.json`,
      `/cafes/${slug}/data/sources/${base}.map.json`,
      `/data/cafes/${slug}/${base}.map.json`,
      `/data/sources/${base}.map.json`,
      `/sources/${base}.map.json`,
      `/data/${base}.map.json`,
    ];
    for (const p of paths) {
      try {
        const r = await fetch(p, { cache:'no-store' });
        if (r.ok) return await r.json();
      } catch(_) {}
    }
    return null;
  }

  function pageFromEntry(entry){
    if (entry == null) return undefined;
    if (typeof entry === 'number') return entry;
    const cand = [entry.from, entry.pdf_from, entry.page, entry.start, entry.p];
    for (const v of cand) { const n = parseInt(v,10); if (Number.isFinite(n) && n>0) return n; }
    return undefined;
  }

  function lookupIn(obj, keys, paraNum){
    if (!obj) return undefined;
    for (const k of keys){
      const bucket = obj[k];
      if (!bucket) continue;
      const hit1 = pageFromEntry(bucket[String(paraNum)]) ?? pageFromEntry(bucket[`osf-${paraNum}`]);
      if (Number.isFinite(hit1)) return hit1;
      if (bucket.paras) {
        const hit2 = pageFromEntry(bucket.paras[String(paraNum)]) ?? pageFromEntry(bucket.paras[`osf-${paraNum}`]);
        if (Number.isFinite(hit2)) return hit2;
      }
    }
    return undefined;
  }

  function lookupInArray(arr, keys, paraNum){
    if (!Array.isArray(arr)) return undefined;
    for (const item of arr){
      const itemKeys = [norm(item.file), onlyFile(item.file), dropNotebook(item.file)].filter(Boolean);
      const overlap  = itemKeys.some(k => keys.includes(k));
      if (!overlap) continue;
      const hit = pageFromEntry(item.paras?.[String(paraNum)]) ?? pageFromEntry(item.paras?.[`osf-${paraNum}`]);
      if (Number.isFinite(hit)) return hit;
    }
    return undefined;
  }

  function pickKey(obj, keys){
    for (const k of keys){ if (obj && Object.prototype.hasOwnProperty.call(obj, k)) return k; }
    return null;
  }

  async function resolveStartPage(pdfPageCount) {
    // ?from= overrides everything
    if (Number.isFinite(fromQ) && fromQ>0) return Math.min(Math.max(fromQ,1), pdfPageCount);

    const map = await loadMap();
    if (!map) return 1;

    const nPara = parseInt(String(paraId).replace(/^osf-/,'') || '0', 10);
    const chKeys = [norm(chapter), dropNotebook(chapter), onlyFile(chapter)].filter(Boolean);

    // 1) flat legacy
    if (paraId && (Number.isFinite(map[paraId]) || Number.isFinite(map[String(nPara)]))) {
      return clamp(applyOffsets(map, chKeys, Number(map[paraId] ?? map[String(nPara)])), pdfPageCount);
    }

    // 2) chapters {}
    if (map.chapters && typeof map.chapters === 'object' && !Array.isArray(map.chapters)) {
      const rel = lookupIn(map.chapters, chKeys, nPara);
      if (Number.isFinite(rel)) return clamp(applyOffsets(map, chKeys, rel), pdfPageCount);
    }
    // 3) chapters []
    if (Array.isArray(map.chapters)) {
      const rel = lookupInArray(map.chapters, chKeys, nPara);
      if (Number.isFinite(rel)) return clamp(applyOffsets(map, chKeys, rel), pdfPageCount);
    }
    // 4) files {}
    if (map.files) {
      const rel = lookupIn(map.files, chKeys, nPara);
      if (Number.isFinite(rel)) return clamp(applyOffsets(map, chKeys, rel), pdfPageCount);
    }
    // 5) direct chapter object
    const rel = lookupIn(map, chKeys, nPara);
    if (Number.isFinite(rel)) return clamp(applyOffsets(map, chKeys, rel), pdfPageCount);

    // fallback
    return 1;

    // ----- helpers for offsets / chapter starts -----
    function clamp(n, max){ return Math.min(Math.max(n,1), max); }

    function applyOffsets(mapObj, chapterKeys, pageFromMap){
      const meta = mapObj.meta || {};
      const starts = meta.starts || meta.chapterStarts || {};    // { "<key>": startPage }
      const offsets = meta.offsets || {};                         // { "<key>": number }
      const relative = !!meta.relative;
      const globalOffset = parseInt(meta.offset||0,10) || 0;

      // pick whichever key the map actually contains
      const chosenStartKey  = pickKey(starts, chapterKeys);
      const chosenOffsetKey = pickKey(offsets, chapterKeys);

      let absolute = pageFromMap;

      // If meta.relative, interpret pageFromMap as 1-based offset inside the chapter
      if (relative && chosenStartKey && Number.isFinite(+starts[chosenStartKey])) {
        const start = parseInt(starts[chosenStartKey],10);
        absolute = start + (pageFromMap - 1);
      }

      // Apply per-chapter additive offset (if any)
      if (chosenOffsetKey && Number.isFinite(+offsets[chosenOffsetKey])) {
        absolute += parseInt(offsets[chosenOffsetKey],10);
      }
      // Apply global additive offset
      absolute += globalOffset;

      return absolute;
    }
  }

  // find the PDF under cafe
  const pdfUrl = await firstReachable([
    `${cafe}/source/${base}.pdf`,
    `${cafe}/sources/${base}.pdf`,
    `${cafe}/pdf/${base}.pdf`,
    `${cafe}/${base}.pdf`,
  ]);
  if (!pdfUrl) {
    $('.main').innerHTML = `<div style="padding:12px">Could not find <b>${base}.pdf</b>.</div>`;
    $('#openRaw').style.display = 'none';
    $('#downloadBtn').style.display = 'none';
    return;
  }

  $('#openRaw').href = pdfUrl;
  $('#downloadBtn').href = pdfUrl;
  $('#downloadBtn').setAttribute('download', base + '.pdf');

  // Blob load to bypass any Content-Disposition headers
  const bytes = await fetch(pdfUrl, { cache:'no-store' }).then(r => r.arrayBuffer());
  const pdf   = await pdfjsLib.getDocument({ data: bytes }).promise;

  let currentPage = await resolveStartPage(pdf.numPages);
  let scale = 1.3;

  const canvas = $('#pageCanvas');
  const ctx    = canvas.getContext('2d');

  async function renderPage(num, opts={smooth:true}) {
    const page = await pdf.getPage(num);
    const vp = page.getViewport({ scale });
    canvas.width  = vp.width;
    canvas.height = vp.height;
    await page.render({ canvasContext: ctx, viewport: vp }).promise;
    $('#pgInfo').textContent = `${currentPage} / ${pdf.numPages}`;
    highlightThumb(num);
    scrollThumb(num, opts.smooth);
  }

  $('#prevBtn').onclick = async ()=>{ if (currentPage>1) { currentPage--; await renderPage(currentPage); } };
  $('#nextBtn').onclick = async ()=>{ if (currentPage<pdf.numPages){ currentPage++; await renderPage(currentPage); } };
  $('#zoomIn').onclick  = async ()=>{ scale = Math.min(scale*1.15, 4);  await renderPage(currentPage, {smooth:false}); };
  $('#zoomOut').onclick = async ()=>{ scale = Math.max(scale/1.15, .5); await renderPage(currentPage, {smooth:false}); };

  const thumbs = $('#thumbs');
  function highlightThumb(i){
    $$('.thumb.active', thumbs).forEach(el => el.classList.remove('active'));
    const el = thumbs.querySelector(`.thumb[data-page="${i}"]`);
    if (el) el.classList.add('active');
  }
  function scrollThumb(i, smooth=true){
    const el = thumbs.querySelector(`.thumb[data-page="${i}"]`);
    if (!el) return;
    thumbs.scrollTo({ top: Math.max(0, el.offsetTop - 8), behavior: smooth ? 'smooth' : 'instant' });
  }

  const thumbObserver = new IntersectionObserver(async (entries)=>{
    for (const entry of entries){
      if (!entry.isIntersecting) continue;
      const c = entry.target;
      if (c.dataset.rendered === '1') continue;
      const i = +c.dataset.page;
      try{
        const p  = await pdf.getPage(i);
        const vp = p.getViewport({ scale: 0.22 });
        c.width  = vp.width;
        c.height = vp.height;
        await p.render({ canvasContext: c.getContext('2d'), viewport: vp }).promise;
        c.dataset.rendered = '1';
      }catch(err){ console.warn('Thumb render failed', i, err); }
    }
  }, { root: thumbs, rootMargin: '300px 0px', threshold: 0.01 });

  for (let i=1;i<=pdf.numPages;i++){
    const c = document.createElement('canvas');
    c.className   = 'thumb';
    c.dataset.page= String(i);
    c.title       = `Page ${i}`;
    c.onclick     = async ()=>{ currentPage = i; await renderPage(currentPage); };
    thumbs.appendChild(c);
    thumbObserver.observe(c);
  }

  // initial render; no smooth so the thumb jumps into view immediately
  await renderPage(currentPage, {smooth:false});

  // Back
  $('#backBtn').onclick = (e) => { e.preventDefault(); if (ret) location.href = ret; else history.back(); };
})();
</script>
</body>
</html>
