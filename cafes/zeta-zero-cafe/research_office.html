<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Research Office</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <base id="ro-base" href="/"> <!-- will be set by JS to the chapter directory -->

  <!-- Styles -->
  <link rel="stylesheet" href="/css/10-components/research-office.css" />

  <!-- MathJax v3 (SVG) for TeX in previews -->
  <script>
    // Allow $...$ and \( ... \) inline; $$...$$ and \[ ... ] display.
    // Don't skip our preview container.
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']]
      },
      options: { skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'code'] },
      svg: { fontCache: 'global' }
    };
  </script>
  <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>

<body>
  <div class="wrap">
    <div class="head">
      <h1 class="ro-title" style="margin:0;">
        Research Office — <span id="cafeName" class="tag"></span>
        <span id="chapName" class="muted ro-sub" style="margin-left:.5rem"></span>
      </h1>
      <a id="backLink" class="btn" href="#">← Back</a>
    </div>

    <div class="row">
      <!-- Left: paragraph preview + pick lists -->
      <div class="card">
        <div class="head">
          <strong>Paragraph preview</strong>
          <span id="paraNum" class="tag">#</span>
        </div>
        <pre id="paraPreview" class="card preview"></pre>

        <!-- Grid / markers stage -->
        <div id="ro-stage" class="card" style="margin-top:12px">
          <img id="ro-page" src="" alt="source page" />
        </div>

        <div class="split" style="margin-top:12px">
          <div>
            <div class="head"><strong>Figures</strong></div>
            <div id="figList" class="list"></div>
          </div>
          <div>
            <div class="head"><strong>Tables</strong></div>
            <div id="tblList" class="list"></div>
          </div>
        </div>

        <div class="bar">
          <button id="copyLink" class="btn">Copy link</button>
        </div>
        <div class="muted" style="margin-top:8px">
          Tip: toggle “member” in any chapter popover to show/hide the app button.
        </div>
      </div>

      <!-- Right: memo editor -->
      <div class="card">
        <div class="head"><strong>Memo to self (Markdown/LaTeX)</strong></div>
        <textarea id="memoBody" placeholder="State the issue, desired change, and rationale..."></textarea>
        <div class="bar">
          <button id="saveDraft" class="btn">Save draft (browser)</button>
          <button id="exportJson" class="btn">Export JSON</button>
          <button id="submitDiscord" class="btn">Submit via Discord</button>
        </div>
        <div class="muted" style="margin-top:8px">
          RFCs are processes, not chats. Draft → step away → revise → then submit.
        </div>
      </div>
    </div>

    <div class="card" style="margin-top:16px">
      <div class="head"><strong>Recent drafts (this browser)</strong></div>
      <div id="memoList" class="list"></div>
    </div>
  </div>

  <!-- App logic -->
  <!-- (Keep the cache-buster fresh if you update /js/research.office.js) -->
  <script defer src="/js/research.office.js?v=2025-10-07e"></script>
  <script type="module">
    /**
     * Research Office Grid & Markers
     * - Reads ?para= & ?chapter= & ?return=
     * - Loads your page image (you can set it via code below)
     * - Overlays grid; click to add point/box markers
     * - Emits reference tokens like: <anchor>@B4  or  <anchor>@(0.423,0.611)
     * - Saves to localStorage; export JSON for overrides
     */

    /*
    const qs = new URLSearchParams(location.search);
    const para = qs.get("para") || "osf-1";
    const chapter = qs.get("chapter") || "";
    const retUrl = qs.get("return") || "";
    const stage = document.getElementById("ro-stage");
    const pageImg = document.getElementById("ro-page");
*/

    // ---- choose an image for the page you’re discussing ----
    // If you already render the PDF page elsewhere, skip this and just ensure
    // #ro-page or a canvas is present under #ro-stage.
//-jh    const thumbRoot = "/cafes/zeta-zero-cafe/thumbs"; // adjust if needed
    // If you know the page range, you can inject page# via your own logic.
    // For demo, load page from ?from param if present:
//-jh    const from = Number(qs.get("from") || "0"); // if your viewer linked here with &from=
//-jh    if (from > 0) pageImg.src = `${thumbRoot}/page-${from}.jpg`;

    // ---- overlay UI (toolbar) ----
    const toolbar = document.createElement("div");
    toolbar.className = "ro-toolbar";
    toolbar.innerHTML = `
  <button id="ro-mode-point">Point</button>
  <button id="ro-mode-box">Box</button>
  <label>Grid:
    <select id="ro-grid-rows"><option>8</option><option selected>12</option><option>16</option><option>24</option></select>×
    <select id="ro-grid-cols"><option>8</option><option selected>12</option><option>16</option><option>24</option></select>
  </label>
  <label style="margin-left:8px">
    <input id="ro-snap" type="checkbox" />
    Snap
  </label>
  <button id="ro-clear">Clear (local)</button>
  <button id="ro-export">Export JSON</button>
  <input id="ro-token" type="text" readonly placeholder="click to copy reference token"/>
`;
    stage.insertAdjacentElement("beforebegin", toolbar);

    const overlay = document.createElement("div");
    overlay.className = "ro-overlay";
    overlay.innerHTML = `<svg id="ro-svg" viewBox="0 0 1000 1000" preserveAspectRatio="none"></svg>`;
    stage.appendChild(overlay);

    const svg = document.getElementById("ro-svg");

    // ---- state ----
    let mode = "point"; // "point" | "box"
    let grid = { rows: 12, cols: 12 };
    let draftBox = null; // {x0,y0,x1,y1}
    const storeKey = `ro:${chapter}:${para}`;

    // load saved
    let markers = loadLocal() || [];

    // ---- helpers ----
    function percentPos(evt) {
      const r = svg.getBoundingClientRect();
      const x = (evt.clientX - r.left) / r.width;
      const y = (evt.clientY - r.top) / r.height;
      return { x: clamp(x, 0, 1), y: clamp(y, 0, 1) };
    }
    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    function toCell({ x, y }) {
      const r = Math.min(grid.rows - 1, Math.floor(y * grid.rows));
      const c = Math.min(grid.cols - 1, Math.floor(x * grid.cols));
      return { row: r, col: c };
    }
    function cellLabel(cell) {
      // Rows labeled A..Z, AA.. if beyond 26 (unlikely)
      const labelRow = (n) => {
        let s = "";
        n = n | 0;
        do { s = String.fromCharCode(65 + (n % 26)) + s; n = Math.floor(n / 26) - 1; } while (n >= 0);
        return s;
      };
      return `${labelRow(cell.row)}${cell.col + 1}`;
    }
    function copyToken(s) {
      const i = document.getElementById("ro-token");
      i.value = s; i.select(); document.execCommand("copy");
      toast("Copied: " + s);
    }
    function toast(msg) { const t = document.createElement("div"); t.className = "ro-toast"; t.textContent = msg; document.body.appendChild(t); setTimeout(() => t.remove(), 1400); }

    function saveLocal() { localStorage.setItem(storeKey, JSON.stringify(markers)); }
    function loadLocal() { try { return JSON.parse(localStorage.getItem(storeKey) || "[]"); } catch { return []; } }

    // ---- draw grid ----
    function drawGrid() {
      const g = svg.querySelector(".ro-grid"); if (g) g.remove();
      const grp = document.createElementNS("http://www.w3.org/2000/svg", "g");
      grp.setAttribute("class", "ro-grid");
      svg.appendChild(grp);

      // lines
      for (let r = 1; r < grid.rows; r++) {
        const y = (r / grid.rows) * 1000;
        const line = lineEl(0, y, 1000, y);
        grp.appendChild(line);
      }
      for (let c = 1; c < grid.cols; c++) {
        const x = (c / grid.cols) * 1000;
        const line = lineEl(x, 0, x, 1000);
        grp.appendChild(line);
      }
      // labels on top & left
      for (let c = 0; c < grid.cols; c++) {
        const x = ((c + 0.5) / grid.cols) * 1000;
        grp.appendChild(labelEl(x, 16, String(c + 1)));
      }
      for (let r = 0; r < grid.rows; r++) {
        const y = ((r + 0.5) / grid.rows) * 1000;
        grp.appendChild(labelEl(14, y, rowLabel(r)));
      }

      function rowLabel(n) { // A, B, …
        let s = ""; n = n | 0;
        do { s = String.fromCharCode(65 + (n % 26)) + s; n = Math.floor(n / 26) - 1; } while (n >= 0);
        return s;
      }
      function lineEl(x1, y1, x2, y2) {
        const L = document.createElementNS("http://www.w3.org/2000/svg", "line");
        L.setAttribute("x1", x1); L.setAttribute("y1", y1);
        L.setAttribute("x2", x2); L.setAttribute("y2", y2);
        return L;
      }
      function labelEl(x, y, text) {
        const T = document.createElementNS("http://www.w3.org/2000/svg", "text");
        T.setAttribute("x", x); T.setAttribute("y", y); T.setAttribute("text-anchor", "middle");
        T.setAttribute("class", "label"); T.textContent = text; return T;
      }
    }

    // ---- render markers ----
    function renderMarkers() {
      const g = svg.querySelector(".ro-markers"); if (g) g.remove();
      const grp = document.createElementNS("http://www.w3.org/2000/svg", "g");
      grp.setAttribute("class", "ro-markers");
      svg.appendChild(grp);

      markers.forEach((m, idx) => {
        if (m.kind === "point") {
          const cx = m.x * 1000, cy = m.y * 1000;
          const el = document.createElementNS("http://www.w3.org/2000/svg", "g");
          el.setAttribute("class", "ro-marker");
          el.dataset.idx = idx;
          const c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
          c.setAttribute("cx", cx); c.setAttribute("cy", cy);
          el.appendChild(c);
          el.addEventListener("click", () => showTokenPoint(m));
          grp.appendChild(el);
        } else if (m.kind === "box") {
          const x = Math.min(m.x0, m.x1) * 1000, y = Math.min(m.y0, m.y1) * 1000;
          const w = Math.abs(m.x1 - m.x0) * 1000, h = Math.abs(m.y1 - m.y0) * 1000;
          const r = document.createElementNS("http://www.w3.org/2000/svg", "rect");
          r.setAttribute("x", x); r.setAttribute("y", y); r.setAttribute("width", w); r.setAttribute("height", h);
          const el = document.createElementNS("http://www.w3.org/2000/svg", "g");
          el.setAttribute("class", "ro-marker"); el.appendChild(r);
          el.addEventListener("click", () => showTokenBox(m));
          grp.appendChild(el);
        }
      });
    }

    function showTokenPoint(m) {
      const cell = cellLabel(toCell(m));
      const tok = `${para}@${cell} • (${m.x.toFixed(3)},${m.y.toFixed(3)})`;
      copyToken(tok);
    }
    function showTokenBox(m) {
      const cx = ((m.x0 + m.x1) / 2), cy = ((m.y0 + m.y1) / 2);
      const cell = cellLabel(toCell({ x: cx, y: cy }));
      const tok = `${para}@${cell} • [(${m.x0.toFixed(3)},${m.y0.toFixed(3)})–(${m.x1.toFixed(3)},${m.y1.toFixed(3)})]`;
      copyToken(tok);
    }

    // ---- interactions ----
    svg.addEventListener("mousedown", (e) => {
      const p = percentPos(e);
      if (mode === "point") {
        markers.push({ kind: "point", x: p.x, y: p.y });
        saveLocal(); renderMarkers(); showTokenPoint(markers[markers.length - 1]);
      } else {
        draftBox = { x0: p.x, y0: p.y, x1: p.x, y1: p.y };
      }
    });
    svg.addEventListener("mousemove", (e) => {
      if (mode !== "box" || !draftBox) return;
      const p = percentPos(e);
      draftBox.x1 = p.x; draftBox.y1 = p.y;
      // draw a temp box
      renderMarkers();
      const tmp = draftBox;
      markers.push({ kind: "box", ...tmp });
      renderMarkers();
      markers.pop();
    });
    svg.addEventListener("mouseup", (e) => {
      if (mode !== "box" || !draftBox) return;
      const p = percentPos(e);
      draftBox.x1 = p.x; draftBox.y1 = p.y;
      markers.push({ kind: "box", ...draftBox });
      draftBox = null;
      saveLocal(); renderMarkers(); showTokenBox(markers[markers.length - 1]);
    });

    // toolbar controls
    document.getElementById("ro-mode-point").onclick = () => { mode = "point"; toast("Mode: point"); };
    document.getElementById("ro-mode-box").onclick = () => { mode = "box"; toast("Mode: box"); };
    document.getElementById("ro-grid-rows").onchange = (e) => { grid.rows = +e.target.value; drawGrid(); };
    document.getElementById("ro-grid-cols").onchange = (e) => { grid.cols = +e.target.value; drawGrid(); };
    document.getElementById("ro-clear").onclick = () => { if (confirm("Clear local markers?")) { markers = []; saveLocal(); renderMarkers(); } };
    document.getElementById("ro-export").onclick = () => {
      const payload = {
        docId: "Old_main",
        chapter,
        anchor: para,
        markers, // normalized [0..1]
        grid
      };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a"); a.href = url; a.download = `${para}.markers.json`; a.click();
      setTimeout(() => URL.revokeObjectURL(url), 1000);
    };
    //document.getElementById("ro-token").onclick = (e) => { if (e.target.value) copyToken(e.target.value); };
    function copyToken(s) {
      const i = document.getElementById("ro-token");
      i.value = s;
      i.select(); document.execCommand("copy");
      toast("Copied: " + s);
    }

    // draw everything
    drawGrid(); renderMarkers();
  </script>

 <script type="module">
  import { initResearchOfficeGrid } from "/js/research-office-grid.js";

  const Q = new URLSearchParams(location.search);
  const PARA    = Q.get("para")    || "osf-1";
  const CHAPTER = Q.get("chapter") || "";

  // Dual-schema lookup: supports chapters[chapter].items[anchor] OR chapters[chapter][anchor]
  async function resolveFromPage(docId, chapter, anchor) {
    const base = "/data/cafes/zeta-zero-cafe/sources";
    const [overrides, map] = await Promise.all([
      fetch(`${base}/${docId}.overrides.json`, { cache: "no-store" }).then(r => r.ok ? r.json() : null).catch(()=>null),
      fetch(`${base}/${docId}.map.json`,       { cache: "no-store" }).then(r => r.ok ? r.json() : null).catch(()=>null),
    ]);

    const getBlock = (root) => root?.chapters?.[chapter] && (root.chapters[chapter].items || root.chapters[chapter]) || null;
    const pick = (obj) => obj?.[anchor] ?? obj?.[`para-${anchor}`] ?? null;
    const norm = (rec) => rec ? (typeof rec.page === "number" ? {from:rec.page,to:rec.page}
                          : (typeof rec.from === "number" && typeof rec.to === "number" ? {from:rec.from,to:rec.to} : null)) : null;

    const o = norm(pick(getBlock(overrides)));
    if (o) return o.from;
    const d = norm(pick(getBlock(map)));
    if (d) return d.from;
    return 0;
  }

  (async () => {
    const explicitFrom = Number(Q.get("from") || "0");
    const FROM = explicitFrom || await resolveFromPage("Old_main", CHAPTER, PARA);

    initResearchOfficeGrid({
      para: PARA,
      chapter: CHAPTER,
      fromPage: FROM,
      pdfUrl: "/data/cafes/zeta-zero-cafe/sources/Old_main.pdf",
      initialZoom: "fit"
    });
  })();
</script>


</body>
</html>