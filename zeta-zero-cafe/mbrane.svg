<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 900 560">
  <style>
    .ink { stroke:#000; stroke-linecap:round; stroke-linejoin:round; fill:none; }
    .rim { stroke:#000; stroke-width:14; fill:none; }
    .bowlFill { fill:#fff; }
  </style>

  <!-- ===== tweakables =====
    cx,cy        : center of rim
    R            : sphere radius (visual scale)
    tiltdeg      : camera tilt (0..60)
    sheets       : target “depth” (≈ number of turns; we do 3 + 288° here)
    wrapdeg      : how much of the outermost revolution is present (gap = 360 - wrapdeg)
    thetaend     : stop latitude (avoid 0 to prevent true pole singularity)
    strokew      : ribbon thickness
    gapcenterdeg : where the rim gap is centered (degrees along the front half)
    rimswell     : thickness of the white rim mask band
  ============================================ -->
  <g id="params"
     data-cx="450" data-cy="190"
     data-R="220" data-tiltdeg="35"
     data-sheets="4" data-wrapdeg="288"
     data-thetaend="0.12" data-strokew="22"
     data-gapcenterdeg="22" data-rimswell="12"></g>

  <!-- Back rim (full ellipse) -->
  <ellipse id="rim-ellipse" class="rim"/>
  <!-- Bowl belly fill -->
  <path id="bowl-belly" class="bowlFill"/>

  <!-- Spiral segments (painted back-to-front) -->
  <g id="spiral-group"></g>

  <!-- Front rim band with a hole (gap) that lets the tail show through -->
  <path id="front-rim-band" class="bowlFill" fill-rule="evenodd"/>

  <!-- Front rim stroke split in two, leaving a gap -->
  <path id="front-rim-seg1" class="rim"/>
  <path id="front-rim-seg2" class="rim"/>

  <!-- Exterior bowl silhouette -->
  <path id="bowl-outline" class="ink" stroke-width="14"/>

  <script><![CDATA[
  (function () {
    const P = document.getElementById('params').dataset;
    const cx = +P.cx, cy = +P.cy, R = +P.r;
    const tilt = (+P.tiltdeg) * Math.PI/180;
    const sheets = +P.sheets;
    const wrapDeg = +P.wrapdeg;
    const thetaEnd = +P.thetaend;
    const strokeW = +P.strokew;
    const gapCenterDeg = +P.gapcenterdeg;
    const rimSwell = +P.rimswell;

    // Rim ellipse radii from tilt
    const rx = R, ry = R*Math.cos(tilt);
    const theta0 = Math.PI/2;

    // Total azimuth traveled: (sheets-1) full turns + wrapDeg of the last
    const phiMax = (sheets - 1) * 2*Math.PI + (wrapDeg * Math.PI/180);
    // Choose k so we descend from rim (theta0) to thetaEnd exactly over phiMax
    const k = (theta0 - thetaEnd) / phiMax;

    // --- helpers ---
    function rotX([x,y,z]) {
      const ct = Math.cos(tilt), st = Math.sin(tilt);
      return [x, y*ct - z*st, y*st + z*ct];
    }
    function proj([x,y,z]) { return [cx + x, cy + y, z]; }
    function spiralPoint(phi) {
      const theta = Math.max(thetaEnd, theta0 - k*phi);
      const s = Math.sin(theta), c = Math.cos(theta);
      const x = R * s * Math.cos(phi);
      const y = R * s * Math.sin(phi);
      const z = R * c;
      return proj(rotX([x,y,z]));
    }
    function ellipsePt(u, rxi, ryi) {
      return [cx + rxi*Math.cos(u), cy + ryi*Math.sin(u)];
    }
    function pathFromPts(pts) {
      if (!pts.length) return "";
      let d = `M ${pts[0][0].toFixed(2)} ${pts[0][1].toFixed(2)}`;
      for (let i=1;i<pts.length;i++) d += ` L ${pts[i][0].toFixed(2)} ${pts[i][1].toFixed(2)}`;
      return d;
    }

    // --- back rim ellipse ---
    const rim = document.getElementById('rim-ellipse');
    rim.setAttribute('cx', cx);
    rim.setAttribute('cy', cy);
    rim.setAttribute('rx', rx);
    rim.setAttribute('ry', ry);

    // --- belly fill (nice bowl belly) ---
    const Lx = cx - rx, Rx = cx + rx, Y = cy;
    const depth = cy + ry*3.3;
    const belly = document.getElementById('bowl-belly');
    belly.setAttribute('d',
      `M ${Lx} ${Y} Q ${cx} ${depth} ${Rx} ${Y} ` +
      `L ${Rx} ${Y+16} Q ${cx} ${depth+28} ${Lx} ${Y+16} Z`
    );

    // --- spiral (depth-sorted line segments) ---
    const segs = [];
    const dphi = 0.03; // smoothness
    let prev = spiralPoint(0);
    for (let phi=dphi; phi<=phiMax; phi+=dphi) {
      const cur = spiralPoint(phi);
      const zAvg = (prev[2] + cur[2]) * 0.5;
      segs.push({ z:zAvg,
        d:`M ${prev[0].toFixed(2)} ${prev[1].toFixed(2)} L ${cur[0].toFixed(2)} ${cur[1].toFixed(2)}`
      });
      prev = cur;
    }
    segs.sort((a,b)=>a.z-b.z); // back to front
    const g = document.getElementById('spiral-group');
    g.innerHTML = "";
    for (const s of segs) {
      const p = document.createElementNS('http://www.w3.org/2000/svg','path');
      p.setAttribute('class','ink');
      p.setAttribute('stroke','#000');
      p.setAttribute('stroke-width', strokeW);
      p.setAttribute('d', s.d);
      g.appendChild(p);
    }

    // --- front rim band with a hole (gap) ---
    const gapRadFull = (360 - wrapDeg) * Math.PI/180; // size of missing chunk
    const u0 = (gapCenterDeg * Math.PI/180);          // center of the gap on front half
    const ua = u0 - gapRadFull/2;
    const ub = u0 + gapRadFull/2;

    // Build band polygon for u in [0,π] (front half)
    const N = 90, du = Math.PI/N;
    const outer = [], inner = [], outerA=[], outerB=[], innerA=[], innerB=[];
    const rxIn = rx - rimSwell, ryIn = ry - rimSwell;

    for (let i=0;i<=N;i++){
      const u = i*du;               // 0..π
      const Pout = ellipsePt(u, rx, ry);
      const Pin  = ellipsePt(u, rxIn, ryIn);
      outer.push(Pout); inner.push(Pin);

      if (u <= ua){ outerA.push(Pout); innerA.push(Pin); }
      if (u >= ub){ outerB.push(Pout); innerB.push(Pin); }
    }

    // Band path (outer loop + inner reversed) minus wedge (ua..ub) using evenodd
    const wedgeOuter = [], wedgeInner = [];
    const Nw = Math.max(12, Math.round((ub-ua)/du));
    const dUw = (ub-ua)/Nw;
    for (let i=0;i<=Nw;i++){
      const u = ua + i*dUw;
      wedgeOuter.push(ellipsePt(u, rx, ry));
      wedgeInner.push(ellipsePt(ub - i*dUw, rxIn, ryIn));
    }

    function closedBand(outerPts, innerPts){
      const all = outerPts.concat(innerPts);
      let d = `M ${all[0][0].toFixed(2)} ${all[0][1].toFixed(2)}`;
      for (let i=1;i<outerPts.length;i++) d += ` L ${outerPts[i][0].toFixed(2)} ${outerPts[i][1].toFixed(2)}`;
      for (let i=0;i<innerPts.length;i++) d += ` L ${innerPts[i][0].toFixed(2)} ${innerPts[i][1].toFixed(2)}`;
      return d + " Z";
    }

    const band = document.getElementById('front-rim-band');
    let dBand = closedBand(outer, inner.slice().reverse());
    // subtract the wedge region (this subpath toggles fill → makes a hole)
    const wedgePath = closedBand(wedgeOuter, wedgeInner);
    band.setAttribute('d', dBand + " " + wedgePath);

    // --- front rim stroke split around the gap ---
    const seg1 = document.getElementById('front-rim-seg1');
    const seg2 = document.getElementById('front-rim-seg2');
    seg1.setAttribute('d', pathFromPts(outerA));
    seg2.setAttribute('d', pathFromPts(outerB));

    // --- exterior bowl silhouette ---
    const out = document.getElementById('bowl-outline');
    out.setAttribute('d', `M ${cx - rx} ${cy+3} Q ${cx} ${depth+18} ${cx + rx} ${cy+3}`);
  })();
  ]]></script>
</svg>
