<!DOCTYPE html>
<html lang="en" xml:lang="en">

<head>
    <title>Virgo Rises - The Algorithm</title>
    <!-- meta http-equiv="content-type" content="text/html; charset=utf-8" /-->
    <script src="https//:polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <!--    MathJax delimeters \( math \) for sites.google
            compatibilaty.  -->
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            TeX: {extensions:["cancel.js"]},
            extensions:["tex2jax.js"]},
            jax: ["input/TeX","output/HTML/CSS"],
            displayAlign: "center",displayIndent: "2em",
            text2jax:{
            inlineMath:  [ [ '$','$'], ['\\(','\\)'] ],
            displayMath:[ [ '$$','$$'], ['\\\[','\\\]'] ],
            processEscapes: true
            });
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    <!-- CSS -->
    <link rel="stylesheet" href="css/vrpaleoplotter.css">
   <!-- Twitter bootstrap 5 -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

 </head>

<body>
    <div>
        <canvas class="uiCanvas" id="vrCanvasPlotRc" style="margin:0;padding:0;" width=600 height=400></canvas>
    </div>
    <div class="userinterface" id="userinterface">

        <div id="setresult">
            <div  class="formpane" id="formpane">
                <div>
                    <fieldset>
                        <legend id="legendseedsmaps" class="">Seeds (max. 9) &amp; mapping</legend>
                        <form>
                            <label for="csvSeeds">csv Seeds</label>
                            <input type="text" id="csvSeeds" value="2,2.02,2.52,2.98,5.5" name="seed_map_preset" onchange="expandSeedSet()"><br />

                            <label for="csvRc">csv Map&nbsp;&nbsp;</label>
                            <input type="text" id="csvRc" value=" " name="seed_map_preset" onchange="plotMarker()">
                        </form>
                    </fieldset>
                </div>
                <div>
                    <fieldset class="formpane">
                        <legend>Select presets:</legend>
                        <form class="frm_changepreset" id="frm_changepreset">
                            <input id="chk_extr" type="checkbox" name="presets" value="19.0999,999999" /><label for="chk_extr">Map extremes convex set</label><br />

                            <input id="chk_f1" type="checkbox" name="presets" value="1" /><label for="chk_f1">Map f(1) Unit value</label><br />

                            <input id="chk_kc" type="checkbox" name="presets" value="11.17" /><label for="chk_kc">Map f(11.17) Hight Kings Chamber</label><br />

                            <input id="chk_seeds" type="checkbox" name="presets" value="2,2.02,2.52,2.98,5.5" /><label for="chk_seeds">The 1<sub>th</sub> Passage (reset the 5 seeds)</label>

                        </form>
                    </fieldset>
                </div>
                <div>
                    <fieldset class="formpane">
                        <legend>Select mapping set:</legend>
                        <form id="frm_setselect">

                            <input id="chk_s1" type="checkbox" name="sets" value="s1" /><label for="chk_s1"><span>Set 1</span> : <span>\({\small \{a\},\{a\times b\},\{a\times b\times c\}}\)</span></label><br />

                            <input id="chk_s2" type="checkbox" name="sets" value="s2" /><label for="chk_s2"><span>Set 2</span> : <span>\({\small \{a\},\{a+b\},\{a+b+c\}}\)</span></label><br />

                            <input id="chk_s3" type="checkbox" name="sets" value="s3" /><label for="chk_s3"><span>Set 3</span> : <span>\({\small \{\sqrt{a}\},\{\sqrt{a+b}\},\{\sqrt{a+b+c}\}}\)</span></label><br />

                            <input id="chk_s4" type="checkbox" name="sets" value="s4" /><label for="chk_s4"><span>Set 4</span> : <span>\({\small \{\sqrt{a}\},\{\sqrt{a\times b}\},\{\sqrt{a\times b\times c}\}}\)</span></label><br />

                            <input id="chk_s5" type="checkbox" name="sets" value="s5" /><label for="chk_s5"><span>Set 5</span> : <span>\({\small \{a^2\},\{a^2\times b^2\},\{a^2\times b^2\times c^2\}}\)</span></label><br />

                            <input id="chk_s6" type="checkbox" name="sets" value="s6" /><label for="chk_s6"><span>Set 6</span> : <span>\({\small \{\sqrt{a}\},\{\sqrt{a}+\sqrt{b}\},\{\sqrt{a}+\sqrt{b}+\sqrt{c}\}}\)</span></label>
                        </form>
                    </fieldset>
                </div>
            </div>
                <div class="tableFixHead" id="theset">
                    <!-- makeTheSeedXTbl()
                         table id="theseedxtbl" -->
                </div>
                <div id="kofi">
                    <script type='text/javascript' src='https://storage.ko-fi.com/cdn/widget/Widget_2.js'></script>
                    <script type='text/javascript'>
                        kofiwidget2.init('Support Me on Ko-fi', '#29abe0', 'L3L6AEPS3');
                        kofiwidget2.draw();
                    </script>
                </div>
            </div> 
            <!-- test dump google sheet data -->
            <div class="container-fluid">
            <div id="place_vrpaleoplotter">data_vrpaleoplotter here</div><br/>
            <div id="place_mplot">tbl_mplot here</div><br/>
            <div id="place_rvalue">tbl_rvalue here</div>
            <div id="tablepane">
            </div>
        </div>
    </div>
    <script>
        // The m(arker) Plot array: mPlot array
        /* The array contains the active mPlot session. 
            Each mPlot session: a plotId; Description; 
            links to: plotWikiURI and a plotDocURI. 
            A focus list of Royal cubits for this plot. */
        var mPlot = {
            plotId: "",
            Description: "",
            plotWikiURI: "",
            DiscordSrvr: "",
            plotDocURI: "",
            mRoyalCubits: ""
        }
        // Populate mPlot array (todo: UI, db)
        // Db of plots and callibration info
        //
        mPlot.plotId = "vr_plt_0000001";
        mPlot.Description = "vr_graph_0001";
        mPlot.plotWikiURI = "void";
        mPlot.DiscordSrvr = "void";
        mPlot.plotDocURI = "void";
        mPlot.mRoyalCubits = "";

        // The r(ange) Value array: rValue
        /*  rValue contains formatting information needed for
            using graphs as backdrop to overlay the algorithms data.
            The mPlot>>rValue has a one-to-many relation.
            To-Do: switch backdrop graphs dynamically, e.g., Alley 2004 Gisp2 ice core, and, for instance, the Lea 2003 Caraco Basin sediment core data.  
        */
        var rValue = {
            plotId: '',
            graphId: '',
            dataSet: '',
            dsetURI: '',
            GraphStored: '',
            GraphFileName: '',
            GraphGenerator: '',
            GraphURI: '',
            GraphDocURI: 0,
            GraphCalib: 0,
            hAxisY: 0,
            hAxisLx: 0,
            hAxisRx: 0,
            rYears: 0,
            hAxisPix: 0,
            hAxisYpPix: 0
        };

        // Populate rValue array (todo: UI, db)
        /*  Db of graphs and callibration info 
            Google share link: Format URI as follows:
        'https://drive.google.com/uc?id=...<long number>...';
        Location: ..\sitesgoogle\vrmedia\graphs */
        rValue.plotId = "vr_plot_0001";
        rValue.graphId = "vr_graph_0001";
        rValue.dataSet = "Alley_Gisp_2004";
        rValue.dsetURI = 'https://drive.google.com/uc?...';
        rValue.GraphStored = "..\virgorises\google_site\vrmedia\graphs";
        rValue.GraphFileName = "Alley, R.B.. 2004. GISP2 Ice Core Temperature .png";
        rValue.GraphGenerator = "..\virgorises\google_site\Embed\sheets\...";
        rValue.GraphURI = 'https://drive.google.com/uc?id=11FcRDMQ1UXYX6g6N9z18GTSiSMvkhDMh';
        rValue.GraphDocURI = "void";
        rValue.GraphCalib = 1950;
        rValue.hAxisY = 317;
        rValue.hAxisLx = 87;
        rValue.hAxisRx = 589;
        rValue.rYears = 20000;
        rValue.hAxisPix = rValue.hAxisRx - rValue.hAxisLx;
        rValue.hAxisYpPix = (rValue.rangeYears / rValue.hAxisPix);

        //  Status array sets
        /*  Each set has an arithmetic template for expanding
            the core seed values into mappings of events in time.`1
            The string literal templates given single quotes, */
            // 'a*b*c*...' --> `${a}*${b}*${c}*...` --> 
            // "2*2.02*2.52* .." --> calc = eval("2*2.02*2.52* ..")
            // Depending on AorM, zero value columns set to 0 or 1.
            // A(dditive)-> 0, or M(ultiplicative)-> 1.
            // e.g., (A)[a+0+c+d+0+...], or (M)[a*1*c*d*1*...] 
    
        var lstSet = {
            set1: {
                chkId: 'chk_s1',
                show: false,
                info: "Set 1",
                strlit: 'a*b*c*d*e*f*g*h*i',
                AorM: 'M',
                csvRc: ""
            },
            set2: {
                chkId: 'chk_s2',
                show: false,
                info: "Set 2",
                strlit: 'a+b+c+d+e+f+g+h+i',
                AorM: 'A',
                csvRc: ""
            },
            set3: {
                chkId: 'chk_s3',
                show: false,
                info: "Set 3",
                strlit: 'Math.sqrt(a+b+c+d+e+f+g+h+i)',
                AorM: 'A',
                csvRc: ""
            },
            set4: {
                chkId: 'chk_s4',
                show: false,
                info: "Set 4",
                strlit: 'Math.sqrt(a*b*c*d*e*f*g*h*i)',
                AorM: 'M',
                csvRc: ""
            },
            set5: {
                chkId: 'chk_s5',
                show: false,
                info: "Set 5",
                strlit: '(a**2)*(b**2)*(c**2)*(d**2)*(e**2)*(f**2)*(g**2)*(h**2)*(i**2)',
                AorM: 'M',
                csvRc: ""
            },
            set6: {
                chkId: 'chk_s6',
                show: false,
                info: "Set 6",
                strlit: '(a**0.5)+(b**0.5)+(c**0.5)+(d**0.5)+(e**0.5)+(f**0.5)+(g**0.5)+(h**0.5)+(i**0.5)',
                AorM: 'A',
                csvRc: ""
            },
            addSets: {
                chkId: null,
                show: false,
                info: "Cumulative list of sets",
                strlit: null,
                AorM: null,
                csvRc: ""
            },
        }

        // Status array presets
        var lstPreset = {
            f1: {
                chkId: 'chk_f1',
                show: false,
                info: "The mapping for 1 Royal cubit:f(1))",
                csvRc: "1"
            },
            seeds: {
                chkId: 'chk_seeds',
                show: false,
                info: "First passage; 5 measures",
                csvRc: "2,2.02,2.52,2.98,5.5"
            },
            kc: {
                chkId: 'chk_kc',
                show: false,
                info: "Height of the King's chamber",
                csvRc: "11.17"
            },
            extr: {
                chkId: 'chk_extr',
                show: false,
                info: "Left, and right infinity convex set",
                csvRc: "19.099999,999999999"
            },
            addPresets: {
                chkId: null,
                show: false,
                info: "Cumulative list of presets",
                csvRc: ""
            }
        }

        // Canvas id="vrCanvasPlotRc"
        /*
            ToDo: ...
            
        */
        var canvas = document.getElementById("vrCanvasPlotRc");
        var ctx = canvas.getContext("2d");
        var img = new Image();
        img.onload = function() {
            ctx.drawImage(img, 0, 0);
            //
            // Initial run 
            // Fetch google sheet data
            getSheetData();
            // Call expandSeedSet()
            expandSeedSet();
            // Call plotMarker()
            plotMarker();
        };
        img.src = rValue.GraphURI; //strDataURI;
        //    
        var rect = canvas.getBoundingClientRect();

        // Change preset event handler
        /* var checkbox =     
            document.querySelector("input[name=checkbox]");
            checkbox.addEventListener('change', function() {
             if (this.checked) {
                console.log("Checkbox is checked..");
             } else {
                console.log("Checkbox is not checked..");
             } });  */
        var chkPres = [];
        //chkPres[0] = document.querySelector("input[id=chk_pall]");
        chkPres[0] = document.querySelector("input[id=chk_f1]");
        chkPres[1] = document.querySelector("input[id=chk_seeds]");
        chkPres[2] = document.querySelector("input[id=chk_kc]");
        chkPres[3] = document.querySelector("input[id=chk_extr]");

        for (let i = 0; i <= 3; i++) {
            chkPres[i].addEventListener('change', function() {
                //console.info(this.id + " checked=" + this.checked);

                if (this.id == 'chk_f1') {
                    lstPreset.f1.show = this.checked;
                };
                if (this.id == 'chk_seeds') {
                    lstPreset.seeds.show = this.checked;

                    /*  If checked: Also resets the csvSeeds field 
                        to the initial 5 seeds from the 1th Passage */
                        if(this.checked){
                            // trigger event change text csvSeeds
                            /*  answered Dec 14, 2022 at 14:21 Hamid Heydari
                                stackoverflow: 
                                The question is Where and How? 
                                "Where" we want the change event to be triggered exactly at the moment after a bunch of codes is executed, and "How" is in the form of the following syntax: */
                            var triggerThis = document.getElementById("csvSeeds");
                            // do stuff: modify the value
                            triggerThis.value = lstPreset.seeds.csvRc;
                            // trigger change event on text box
                            triggerThis.dispatchEvent(new Event("change"));
                        }
                };
                if (this.id == 'chk_kc') {
                    lstPreset.kc.show = this.checked;
                };
                if (this.id == 'chk_extr') {
                    lstPreset.extr.show = this.checked;
                };
                // Add presets to csvRc and redraw
                procesPreset(lstPreset)
            })
        };

        function procesPreset(lstPreset) {

            //  Set addPresets.csvRc = ""
            lstPreset.addPresets.csvRc = "";
            for (x in lstPreset) {
                if (lstPreset[x].show) {
                    lstPreset.addPresets.csvRc += "," + lstPreset[x].csvRc;
                }
            }
            /*   plotMarker() will add the current preSet 
                 selection (lstpreSet.addSets) to the 
                 Rc list got from the csvMap manual entry. */
                 plotMarker();
        }

        //changeSet event handler    
        var chkSet = [];
        //chkSet[0] = document.querySelector("input[id=chk_sall]");
        chkSet[0] = document.querySelector("input[id=chk_s1]");
        chkSet[1] = document.querySelector("input[id=chk_s2]");
        chkSet[2] = document.querySelector("input[id=chk_s3]");
        chkSet[3] = document.querySelector("input[id=chk_s4]");
        chkSet[4] = document.querySelector("input[id=chk_s5]");
        chkSet[5] = document.querySelector("input[id=chk_s6]");

        for (i in chkSet) {
            chkSet[i].addEventListener('change', function() {
                //console.info(this.id + " checked=" + this.checked);
                if (this.id == 'chk_s1') {
                    lstSet.set1.show = this.checked;
                };
                if (this.id == 'chk_s2') {
                    lstSet.set2.show = this.checked;
                };
                if (this.id == 'chk_s3') {
                    lstSet.set3.show = this.checked;
                };
                if (this.id == 'chk_s4') {
                    lstSet.set4.show = this.checked;
                };
                if (this.id == 'chk_s5') {
                    lstSet.set5.show = this.checked;
                };
                if (this.id == 'chk_s6') {
                    lstSet.set6.show = this.checked;
                };
                // Add to csvRc
                procesSet(lstSet) //
            });
        }

        // Form change: Select mapping set
        function procesSet(lstSet) {
            let ad_Rc = document.querySelector("input[id=csvRc]");
            // Prevent addSets from accumulating
            lstSet.addSets.csvRc = "";
            for (x in lstSet) {
                if (lstSet[x].show) {

                    populateSetCsvRc(x)
                    lstSet.addSets.csvRc += "," + lstSet[x].csvRc;
                    //console.info(lstSet[x]);
                }
            }
            /*   plotMarker() will add the current set 
                 selection (lstSet.addSets) to the 
                 Rc list got from the csvMap manual entry. */
            plotMarker();
        }

        /*  populateSetCsvRc(lstSet[x]) */
        function populateSetCsvRc(x) {
            // Declare string litteral variables (max 9)
            // initialize for Additive, or Multiplicative 
            // arithmatic mapping.
            let AorM = (lstSet[x].AorM == 'M' ? 1 : 0);
            // let a, b, c, d, e, f, g, h, i = 0;
            let template = lstSet[x].strlit;
            let toMatch = "abcdefghi";
            var prepSeeds = [];
            var curSeeds = document.getElementById("csvSeeds").value
            // + 2, account for columns "dec", and "binary"
            var numcols = curSeeds.split(",").length + 1;
            // query selector by id: #theseedxtbl_body
            var tbody = document.querySelectorAll("#theseedxtbl_body")[0];
            var TRs = tbody.querySelectorAll("tr");
            for (let a = 0; a < TRs.length; a++) {
                var TDs = TRs[a].querySelectorAll("td");

                /*  tupleSeeds is dimentioned for the max
                    number of seeds alowed. Added are two
                    fields for the column 'dec', and 'binary'.*/
                var tupleSeeds = {
                    0: "",
                    1: "",
                    2: "",
                    3: "",
                    4: "",
                    5: "",
                    6: "",
                    7: "",
                    8: "",
                    9: "",
                    10: ""
                };

                /*  Those fields which are not used for the 
                    current combination, are set to '0' for
                    sets that are additive in character, and
                    '1' for multiplicative sets. */
                for (let j = 0; j <= numcols; j++) {
                    if (TDs[j].innerHTML !== '0') {
                        tupleSeeds[j] = TDs[j].innerHTML;
                    } else {
                        tupleSeeds[j] = AorM;
                    }
                }
                prepSeeds.push(tupleSeeds);
            }

            /*  Rebuild the mappings for this set. This not
                a static set; Each set of n seeds has 2^n-1 
                mappings. i.e., [1,3,7,15,31,63,127,255,511] */
            lstSet[x].csvRc = "";

            // Select template for this set
            var useTemplate = lstSet[x].strlit;
            for (let y = 0; y <= numberXhaustive; y++) {

                // Restore template
                template = useTemplate;
                // Save 'Math.' from death by replacement   
                template = template.replace("Math.", "M@t@.");
                for (let i in toMatch) {
                    //template = template.replace(toMatch.charAt(x), eval(toMatch.charAt(x)));
                    if (i <= numcols - 2) {
                        template = template.replace(toMatch.charAt(i), prepSeeds[y][numcols - i]);
                    } else {
                        template = template.replace(toMatch.charAt(i), AorM);
                    }
                };
                // Take 'Math.' out of hiding, all is safe     
                template = template.replace("M@t@.", "Math.");
                // template = "`${" + template + "}`";
                // Calculate the template
                let calc = eval(("`${" + template + "}`"));
                //console.info(template + '= ' + calc);
                // Add calc to lstSet.addSets.csvRc
                lstSet[x].csvRc += "," + calc;
            }
        }

        /**/
        var theSet = '',
            binaryLabels = '',
            numVars = '',
            numberXhaustive = '';

        function expandSeedSet() {
            var varList = document.getElementById("csvSeeds").value;

            /* convert the varList to a set of unique values
                The algorithm maps (combinations of) seed values
                to a specific window in time.
            */
            // Begin simple set construction
            var varArray = eval("[" + varList + "]");
            // sort the array in ascending order, and
            // maintain numerical order
            // https://www.w3schools.com/jsref/jsref_sort.asp
            varArray.sort(function(a, b) {
                return a - b
            });
            // convert the given varList to a set of unique values
            let oldValue = null;
            let purged = 0;
            for (let i in varArray) {
                if (varArray[i] == oldValue) {
                    varArray[i] = null;
                    purged++;
                } else {
                    oldValue = varArray[i]
                }
            }

            // Sort the array, null values gather at the end
            varArray.sort();
            // Pop the null values off the array
            for (let i = 1; i <= purged; i++) {
                oldValue = varArray.pop()
            }
            // Only sets of unique seeds are alowed, so rewrite
            // the csvseeds textinput with the cleaned and sorted list
            // Sort the seeds in numerical order
            varArray.sort(function(a, b) {
                return a - b
            });
            var cleanVal = "";
            for (let i = 0; i <= varArray.length - 1; i++) {
                //prevent adding last seperator
                cleanVal += varArray[i] + (i < varArray.length - 1 ? "," : "");
            }
            document.getElementById("csvSeeds").value = cleanVal;
            // End simple set construction
            /*
                For purpose of this program;
                The expanded table for the five seed values 
                expand to (2^5)-1 = 31 combinations; Those are  
                mapped by 6 sets of aritmethic operations, yielding
                a connected graph of 6x31=186 (hypothesized)
                intentionally mapped events.
                While open to  the presence of more extensive sets, inhere I limit #seedvalues up to 9 seeds to play with.
                9 seedvalues yield 511x6=3072 'mapped events', and will be hard to validate by mere visual inspection
                for any intended pattern mapping.
            */
            // Validate number of seed values
            //console.info(`You entered more than 9, (${varArray.length}), unique seed values. \n ${varArray}.`);
            /*
            <legend id="legendseedsmaps" class="maxseeds">Seeds (max. 9) &amp; mapping</legend>
                        */
            let seedAlert = document.getElementById("legendseedsmaps");
            if (varArray.length > 9) {
                seedAlert.classList.add("maxseeds");
                document.getElementById("csvSeeds").focus;
                return;
            };
            seedAlert.classList.remove("maxseeds");

            // Proceed with a set of maximum 9 unique values 

            /* convert the set of unique values to a exhaustive
                list of combinations. This list of seeds will form 
                the basis for consecutive additive, and multiplicative
                operations, which discloses an inter related graph of 
                vertices and edges, mapping specific moments in the 
                window in time.
            */
            numVars = varArray.length;
            // 
            // Generate the list of combinations
            // 2^{numVars} => {1,2,4,8,16,32,64,128,...}
            // The five seeds give (2x(2^5))-1 = 31 combinations!
            numberXhaustive = Math.pow(2, numVars) - 1;
            //
            let buildSet = "[";
            let combiLine = "";
            let chkbit = 1;
            let padBin = "";
            let binaryColumns = "";
            // makeTheSeedXTbl(theSet, binaryLabels)
            binaryLabels = "['dec','binary',"
            //
            for (let j = 0; j <= numberXhaustive; j++) {
                // pad the line with preceding zeros (0)
                // up to numVars in length 
                padBin = "'" + "0".repeat(numVars - (j.toString(2).length)) + j.toString(2) + "'";
                //
                combiLine = '[' + j + ',' + padBin + ',';
                for (let i = numVars - 1; i >= 0; i--) {
                    // Piggyback column labeling on first itteration
                    if (j == 0) {
                        binaryLabels += "'" + String.fromCharCode(97 + i) + "'" + (i > 0 ? "," : "]");
                        // console.info(binaryLabels)
                    };
                    //
                    // Compare bit position: 'n' AND j, 
                    // e.g., b100(4) AND dec6(b110) = true 
                    if ((chkbit << i) & j) {
                        //console.info('(chkbit << i) & j -> keep value;
                        binaryColumns = varArray[i] + ',' + binaryColumns;
                    } else {
                        // Set value to 0 (zero)
                        binaryColumns = 0 + ',' + binaryColumns;
                    }
                    // Concat binary columns
                    combiLine += binaryColumns;
                    //console.info(combiLine);
                    binaryColumns = "";
                }
                // Strip of last delimeter, add end bracket and delimeter.
                combiLine = combiLine.substr(0, combiLine.length - 1) + '],';
                //console.info(combiLine);
                buildSet += combiLine;
            }
            // Strip last delimeter and add closing bracket
            buildSet = buildSet.substr(0, buildSet.length - 1) + ']';
            //
            // console.info(buildSet);
            let expandedSet = eval(buildSet);

            // 
            theSet = Array.from(expandedSet);
            makeTheSeedXTbl();
            plotMarker();
        }

        function makeTheSeedXTbl() {
            // Build html table
            let table = document.createElement('table');
            let tcaption = document.createElement('caption');
            let thead = document.createElement('thead');
            let tbody = document.createElement('tbody');
            table.setAttribute('id', 'theseedxtbl');
            tbody.setAttribute('id', 'theseedxtbl_body');
            // Set caption
            tcaption.innerHTML = "<b>The&nbsp;Seeds</b><br/><small>2<sup>" + numVars + "</sup>-1=" + numberXhaustive + "&nbsp;combinations</small>";

            table.appendChild(tcaption);
            table.appendChild(thead);
            table.appendChild(tbody);

            // Creating and adding data to first row of the table
            let row_1 = document.createElement('tr');
            // generate header
            // binaryLabels to Array
            // console.info(binaryLabels);
            binaryLabels = eval(binaryLabels);
            let heading = [];
            for (h = 0; h <= numVars + 1; h++) {
                heading[h] = document.createElement('th')
                heading[h].innerHTML = binaryLabels[h];
                row_1.appendChild(heading[h]);
            }
            //
            thead.appendChild(row_1);
            let row = [];
            let data = [];
            for (r = 0; r <= numberXhaustive; r++) {
                row[r] = document.createElement('tr');
                if (r % 2) {
                    row[r].className = 'cellcolor'
                };
                for (d = 0; d <= theSet[r].length - 1; d++) {
                    data[d] = document.createElement('td');
                    data[d].innerHTML = theSet[r][d];
                    row[r].appendChild(data[d]);
                }
                tbody.appendChild(row[r]);
            }
            // remove (previous) table in div 'theset'
            document.getElementById('theset').innerHTML = "";

            // Adding the entire table to element 'theset'
            document.getElementById('theset').appendChild(table);
            console.info(document.getElementById('theseedxtbl'));

            // New table, trigger redraw current selection
            // Just toggling preset id='chk_s1' which forces
            // recalculating mappings based on new 2^n combinations
            triggerRedrawAll();
        }

        function triggerRedrawAll() {
            /* Just toggling preset id='chk_s1' which forces
            recalculating mappings based on 'n' seeds, or 
            2^n combinations. Trigger twice to leave current 
            user selection unchanged */
            for (let i = 0; i <= 1; i++) {
                const event = new MouseEvent("click", {
                    view: window,
                    bubbles: true,
                    cancelable: false, //true,
                });
                const cb = document.getElementById("chk_s1");
                const cancelled = !cb.dispatchEvent(event);

                if (cancelled) {
                    // A handler called preventDefault.
                    // alert("cancelled");
                } else {
                    // None of the handlers called preventDefault.
                    // alert("not cancelled");
                }
            }
        }

        //function plotMarker() 
        function plotMarker() {
            let plotSelection = "";

            /*  Preserve users manually added  Royal cubit values */
            let manualInput = document.getElementById("csvRc").value;
            plotSelection += manualInput;

            /*  plotMarker() will add the current preset 
                selection (lstPreset.addPresets.csvRc) to the 
                Rc list got from the csvMap manual entry. */
            plotSelection += lstPreset.addPresets.csvRc;

            /*  plotMarker() will add the current set 
                selection (lstSet.addSets.csvRc) to the 
                Rc list got from the csvMap manual entry. */
            plotSelection += lstSet.addSets.csvRc;

            /*  shade the convex set area   
                Array declaration: Use eval() for on the fly array construction. */
            lstRc = eval("[" + plotSelection + "]");
            // Preperation to itterate over list of Rc
            // Array for holding the current Royal Cubit
            var curRc = {
                listItem: 0,
                Rc: "",
                Calib: 0,
                RcX: 0,
                mLength: 205,
                mLbl: "",
                f_calc: null,
            }

            // shade convex set area
            shadeConvexSet();

            // Start loop over Rc list
            for (let x in lstRc) {
                curRc.listItem = x;
                //
                curRc.Rc = lstRc[x];

                /*  Call The Algorithm with current 
                    Royal cubit value -AND- the callibration
                    for the current graph, e.g., A graph based
                    on years before present (ybp) is likely 
                    to start at 1950 CE. */

                curRc.f_calc = f(lstRc[x], rValue.GraphCalib, rValue.rYears);

                /*  The algorithm calculates offsets from 
                    2450 BCE, 4400 years have to be added to 
                    map ybp correctly on our present day graph. */
                curRc.Calib = 2450 + rValue.GraphCalib;

                /*  Draw the mapping in the shape of a vertical
                    line. */
                curRc.RcX = (rValue.hAxisRx - rect.left) - (((curRc.f_calc.Ybo + curRc.Calib) / (rValue.rYears)) * rValue.hAxisPix);

                curRc.mLbl = curRc.Rc.toString;

                // Define a new Path:
                ctx.beginPath();

                // Define a start Point
                ctx.moveTo((curRc.f_calc.RelX * rValue.hAxisPix) + rValue.hAxisLx - rect.left, rValue.hAxisY - 20);

                // Define an end Point
                ctx.lineTo((curRc.f_calc.RelX * rValue.hAxisPix) + rValue.hAxisLx - rect.left, rValue.hAxisY - curRc.mLength);

                // Stroke it (Do the Drawing)
                ctx.stroke();

            }

        }

        //   
        /*  The convex set. All function values map Royal cubits
            line segments to presessional degree circle segments.  
            The algorithm's domain are (all) the rational numbers,
            given in Royal cubits. The output range, f(Rc)∈ℝ, is 
            given in Gon (decimal degrees), but are treated as if 
            x°(360 degrees). 'Gon' is a correct assumption because
            the range consists of a 200 gon semi circle. It is 
            obvious that the gon is treated as if a value in x°
            because, without further conversion, those gon are multiplied by 72 presessional years. The presessional
            model, of course, is based on the 12 sign 360 dgr(°),
            minute('), second ('') system. */

        // Indicate convex set by shading
        function shadeConvexSet() {
            //
            ctx.drawImage(img, 0, 0);
            //f(1000000000.... close enough to infinity right
            var rightX = (f(1000000000, rValue.GraphCalib, rValue.rYears).RelX * rValue.hAxisPix) + (rValue.hAxisLx - rect.left);
            //f(19.099999.... close enough to infinity left
            var leftX = f(19.099999, rValue.GraphCalib, rValue.rYears).RelX * rValue.hAxisPix + (rValue.hAxisLx - rect.left);
            var topY = rValue.hAxisY - 225;
            var heigth = 215;
            var width = rightX - leftX;
            // Define a new Path:
            ctx.beginPath();
            // Convex set
            ctx.fillStyle = "lightblue"; //"#F5F5F5";
            //Draw convex set window
            ctx.globalAlpha = 0.21;
            ctx.fillRect(leftX, topY, width, heigth);
            ctx.globalAlpha = 1.0;
            // Stroke it (Do the Drawing)
            ctx.stroke();

            ctx.strokeStyle = "black"; //"#F5F5F5";
            //End draw convex set window
        }

        // The Algorithm    
        /*
            The algorithm has as input domain the rational numbers,
            given in Royal cubits. The output range, f(Rc)∈ℝ, is 
            given in Gon (decimal degrees), but is treated as if 
            x°(360 degrees). 'Gon' is a correct assumption because
            the output is converted to a 200 gon semi circle.
            The gon is treated as if x° because without conversion,
            the gon are multiplied by 72 presessional years, which
            is modelled using the 12 sign 360 dgr°, minute', second''
            system.
        */
        function f(RoyalCubit, GraphCalib, RangeX) {
            const cGon = 100 * (2 / (RoyalCubit * (Math.PI / 6)));
            const cIsFloor = Math.floor(cGon / 10);
            const cF_hbar = cIsFloor === 0 ? 1 : cIsFloor;
            const cDegPreses = 10 * (cGon / cF_hbar);
            const cYbo = cDegPreses * 72;
            const cCalibPlus = (2450 + GraphCalib);
            const cYbp = (cDegPreses * 72) + (2450 + rValue.GraphCalib);
            const cRelX = 1 - (cYbp / RangeX);

            // return array of values
            const f_calc = {
                Rc: RoyalCubit,
                gon: cGon,
                isFloor: cIsFloor,
                f_hbar: cF_hbar,
                degPreses: cDegPreses,
                Ybo: cYbo,
                CalibPlus: cCalibPlus,
                Ybp: cYbp,
                RelX: cRelX
            };
            return f_calc
        }
    </script>
        <script>
            // getSheetData() fetches all tables
            getSheetData()
           
            // Asynchronus fetch(url)
            // For delay add .then(sleeper(20)) in fetch().then list
            function sleeper(ms) {
                return function(x) {
                return new Promise(resolve => setTimeout(() => resolve(x), ms));
              };
            }
    
           function getSheetData() {
                /**
                 * data.substring(47).slice(0,-2)) pics data part from 
                 * the sheets response string. substring(4) (from pos 47, 
                 * just past the brace to the end), and from this slice 
                 * the part from the mostleft character (0th), uptil -2
                 * characters from the end of the response string
                 * .i.e.,(cutting of the last brace from the string.)
                 */
                let gid = '0'
                let url = ''
                let id = '';
                // Fetch 'data_vrpaleoplotter';
                // For delay add .then(sleeper(20)) in fetch().then list
                id = '1p6pFIaJQI_KIA8KFmJQmAkF8b9HzX1y6NCu9gIBTaDg';
                url = 'https://docs.google.com/spreadsheets/d/' + id + '/gviz/tq?tqx=out:json&tq&gid=' + gid;
                fetch(url)
                .then(response => response.text())
                .then(data => document.getElementById("place_vrpaleoplotter").innerHTML=sheetToTbl(data.substring(47).slice(0, -2),"data_vrpaleoplotter","table"))
    
                // Fetch 'tbl_mplot'
                id = '1QRR_9DZsyRXTc2hsp4U5YX8gC4vtbWCi2KFugu63Cug';
                //arrayFromSheet(tbl_mplot_id);
                url = 'https://docs.google.com/spreadsheets/d/' + id + '/gviz/tq?tqx=out:json&tq&gid=' + gid;
                fetch(url)
                .then(response => response.text())
                .then(data => document.getElementById("place_mplot").innerHTML=sheetToTbl(data.substring(47).slice(0, -2),"tbl_mplot","table"))
    
                // Fetch 'tbl_rvalue'
                id = '1bB-SIFalx3B3WfEzbuobIr6utT0kU7LKuEyuxzLT2VY';
                //arrayFromSheet(tbl_rvalue_id);
                url = 'https://docs.google.com/spreadsheets/d/' + id + '/gviz/tq?tqx=out:json&tq&gid=' + gid;
                fetch(url)
                .then(response => response.text())
                .then(data => document.getElementById("place_rvalue").innerHTML=sheetToTbl(data.substring(47).slice(0, -2),"tbl_rvalue","table"))
             }
    
            // called from within fetch(url)
            function sheetToTbl(jsonString,atr_id,atr_class) {
                var json = JSON.parse(jsonString);
                console.info(json);
                var table = '<table class="'+atr_class+ '" id="'+atr_id+'"><tr>'
                // Retrieve the header labels got from the first row
                json.table.cols.forEach(column => table += '<th>' + column.label + '</th>')
                // Itterate over all rows and retrieve the cell data
                table += '</tr>'
                json.table.rows.forEach(tuple => {
                    table += '<tr>'
                    tuple.c.forEach(attribute => {
                        // try fails if cell value is null, then assign 
                        // contents= '' (empty string)
                        try {
                            var contents = attribute.f ? attribute.f : attribute.v
                        } catch (e) {
                            var contents = ''
                        }
                        table += '<td>' + contents + '</td>'
                    })
                    table += '</tr>'
                })
                table += '</table>'
                return table
            };
        </script>
    
</body>

</html>